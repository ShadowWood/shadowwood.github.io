{"meta":{"title":"ShadowWood's Blog","subtitle":"睡睡觉，玩玩游戏编编程","description":"不知道写啥0.0","author":"Shadow Wood","url":"https://shadowwood.me"},"pages":[{"title":"About Me","date":"2016-08-16T12:32:29.000Z","updated":"2017-02-25T07:33:54.000Z","comments":false,"path":"about/index.html","permalink":"https://shadowwood.me/about/index.html","excerpt":"","text":"class Coder { constructor () { let fullPower = 100; this.fullName = &apos;shadowwood&apos; this.programLang = { &apos;Python&apos;: 60/100, &apos;Javascript&apos;: 63/100, &apos;Html/Css&apos;: 30/100, &apos;C/C++&apos;: 30/100 }; this.devloping = &apos;web, mostly back end&apos;; this.github = &apos;https://github.com/shadowwood&apos;; this.email = &apos;shadowwood@foxmail.com&apos;; this.gmail = &apos;w308346420@gmail.com&apos;; this.blog = &apos;shadowwood.me&apos; } } let ShadowWood = new Coder() 曾几何时 想成为一个有趣的人，一不小心却成了一个逗比。 想成为一个权威的人，一不小心又成了一个逗比。 想成为一个有魅力的人，最后还是变成了一个逗比。"},{"title":"所有分类","date":"2014-12-22T04:39:04.000Z","updated":"2018-04-19T11:59:43.756Z","comments":false,"path":"categories/index.html","permalink":"https://shadowwood.me/categories/index.html","excerpt":"","text":""},{"title":"resume","date":"2016-08-12T03:10:19.000Z","updated":"2017-04-06T16:16:40.000Z","comments":false,"path":"resume/index.html","permalink":"https://shadowwood.me/resume/index.html","excerpt":"","text":"联系方式 手机：15682513909 Email：shadowwood@foxmail.com QQ：303846420 个人信息 吴晟雨/男/1994 本科/电子科技大学通信与信息工程学院网络工程系 工作年限：1年 技术博客：https://shadowwood.me Github：https://github.com/shadowwood 期望职位：web研发工程师 工作经历广州多益网络有限公司 （ 2016年7月 ~ 至今 ）跨境电商网站Ubuy主要负责Node.js服务端，同时也负责前端页面和后台管理页面的开发维护；项目架构为 Express + Mysql第三方支付主要是使用 Paypal 357游戏资讯网（重构）该项目较为庞大，是多个项目的重新整合，在项目重构后，该项目主要分为3个部分： datacenter: 数据中心，负责数据库增删改查业务及向其他服务提供api接口 admin: 后台管理应用，采用express + Vue.js开发 web: 主要负责前端页面渲染 我参与了该项目的主要重构工作，现在是该项目的主要负责人。 其中，我在项目中参与解决了几个难点问题： 热门专区站点页面可编辑需求，策划和编辑可以在管理后台自定义热门专区站点页面； 提高站点页面访问速度； 规范git版本管理控制流程； 项目自动化测试及自动部署； 其他项目 考勤管理系统：公司内部考勤系统 appnnie排行榜：appnnie数据抓取及数据展示 技术文章 浅谈js异步流程框架async与Promise的区别 Promise的简单实现 Express源码分析 技能清单 Web开发：Python/Node Web框架：Express/Django/Meteor 前端框架：Bootstrap/AngularJS/Vue.js 前端工具：Bower/Gulp/Grunt/Webpack 数据库相关：MySQL/MongoDB/Redis 进程管理及服务器代理工具: pm2/nginx 版本管理工具：Svn/Git 单元测试：Mocha/Chai 支付相关开发：Paypal 技能关键字 Javascript Node.js html/css Python Git 致谢感谢您花时间阅读我的简历，期待能有机会和您共事。"},{"title":"","date":"2014-12-22T04:39:04.000Z","updated":"2018-04-19T12:00:43.495Z","comments":false,"path":"tags/index.html","permalink":"https://shadowwood.me/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"leetcode刷题记---最长回文子串","slug":"2019-09-08-leetcode-longest-palindrome","date":"2019-09-08T02:00:00.000Z","updated":"2019-09-08T10:05:59.313Z","comments":true,"path":"2019/09/08/2019-09-08-leetcode-longest-palindrome/","link":"","permalink":"https://shadowwood.me/2019/09/08/2019-09-08-leetcode-longest-palindrome/","excerpt":"问题描述给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 1： 输入: “babad”输出: “bab”注意: “aba” 也是一个有效答案。示例 2： 输入: “cbbd”输出: “bb” 题目出处：leetcode","text":"问题描述给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 1： 输入: “babad”输出: “bab”注意: “aba” 也是一个有效答案。示例 2： 输入: “cbbd”输出: “bb” 题目出处：leetcode 题目分析回文字符串，即正读和反读都相等的字符串，例如”aba, bb, aabbaa”都是回文字符串。 笔者作为一个算法菜鸡，第一眼看到这个题目首先想到的便是把输入字符串的所以子串遍历出来，然后挨个验证每个子串是否是回文字符串，从中找出最长的输出，并且题目描述中可以看出，如果存在多个最长子串，那么要求输出位置最靠近原字符串尾部的那一个。 暴力解题法顺着最开始的思路来剖析一下我们需要干一些什么事情： 首先，需要遍历出所有的子串。因为需要找出最长的回文子串，那么先从最长的子串找起，这里需要一个循环遍历子串的长度length；（第一个循环） 然后，对于每个给予的长度length，再遍历出所有需要的子串；（第二个循环） 最后对于每个子串，再对其验证是否为回文子串；（第三个循环） 顺着这个思路，开始编码： 12345678910111213141516171819202122232425262728293031323334353637383940414243function longestPalindrome(s) &#123; if (s.length &lt;= 1) &#123; return s; &#125; // 验证子串函数 function varifySubStr(subStr) &#123; let start = 0; let end = subStr.length - 1; while (start &lt; end) &#123; if (subStr[start] !== subStr[end]) &#123; return false; &#125; start++; end--; &#125; return true; &#125; for(let length = s.length; length &gt; 0; length--) &#123; // 第一个循环，从最长的长度开始遍历长度 let start = s.length - length; let end = s.length - 1; while(start &gt;= 0) &#123; // 第二个循环，从原始字符串的尾部开始找出所有的子串 let substr = s.substring(start, end+1); if (varifySubStr(substr)) &#123; // 如果找到了回文字符串，就立即返回 return substr; &#125; end--; start--; &#125; &#125; return '';&#125;; 以上的思路还是很简单的，但是时间复杂度着实高(O(n^3))，只能勉强通过leetcode测试。 暴力破解法： 时间复杂度：O(n^3); 空间复杂度: O(1); 优化思路那么从暴力破解法开始看，这三个循环是否有可以优化的点呢？ 已经验证过找到的子串能否重复利用以减少子串的多次遍历呢？ 在验证子串的时候使用了一个循环，能否将这个循环和查找子串的过程的循环结合起来以减少复杂度呢？ 动态规划法先从第一个点入手，我们需要将已经判断过子串信息便能后续利用起来。那么应该如何利用呢？ 在暴力破解法中的校验过程中，可以将已经判断过不符合条件的子串记录在一个varifyMap，即记录： 子串的中心点center; 上一次以这个中心收缩的不符合条件的右边界right; 并且当之后传入同样以center为中心的子串，如果该子串的边界大于等于上次不符合条件的边界记录，那么该子串一定不是回文子串。于是我们将代码更改如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function longestPalindrome(s) &#123; if (s.length &lt;= 1) &#123; return s; &#125; // 存储已经判断过的子串信息 let varifyMap = &#123;&#125;; // 验证子串函数 function varifySubStr(start, end) &#123; let center = (start + end) / 2; if (varifyMap[center] &amp;&amp; end &gt;= varifyMap[center]) &#123; // 如果之前有相同中心的判断记录并且不符合条件的边界小于等于需要判断的子串，那么该子串一定不是回文子串 return false; &#125; while (start &lt; end) &#123; if (s[start] !== s[end]) &#123; // 将不符合条件的边界存储起来 varifyMap[center] = end; return false; &#125; start++; end--; &#125; return true; &#125; for(let length = s.length; length &gt; 1; length--) &#123; // 第一个循环，从最长的长度开始遍历长度 let start = s.length - length; let end = s.length - 1; while(start &gt;= 0) &#123; // 第二个循环，从原始字符串的尾部开始找出所有的子串 if (varifySubStr(start, end)) &#123; // 如果找到了回文字符串，就立即返回 return s.substring(start, end+1); &#125; end--; start--; &#125; &#125; return s[s.length - 1];&#125;; 似乎感觉优化成功了，但是这里使用了更多的存储空间来存储之前的判断信息，即使减少的时间复杂度，但是增加了更多的空间复杂度。如果遇到特别长的并且最长回文子串很短的子串，这个算法反而会花费更多的计算时间。 优化结果(相较于暴力破解法): 时间复杂度 O(n^3) =&gt; O(n^2); 空间复杂度 O(1) =&gt; O(n^2); 中心扩展法那么现在尝试第二种思路 =&gt; 将验证过程的循环和子串遍历的循环整合成一个。 经过上面的尝试，不难发现，确定一个回文子串有两种方法： 找到子串的左右边界； 找到子串的中心点和其中的一个边界点； 暴力破解法尝试的是第一种方法，那第二种方法是不是有奇效呢？那我们来试一下： 遍历原字符串的每一个点，以其为中心center； 以center向左右两侧展开，找到以center为中心点的最长的回文串； 在2的循环中，记录并比较回文串的长度，存储最长的回文子串并返回； OK! Start coding! 123456789101112131415161718192021222324252627282930function longestPalindrome (s) &#123; if (!s) &#123; return ''; &#125; // 以center为中心展开，查找最长的回文串 function findLongestResByCenter(s, left, right) &#123; let [l, r] = [left, right]; while (l &gt;= 0 &amp;&amp; r &lt; s.length &amp;&amp; s[l] == s[r]) &#123; l--; r++; &#125; return [l+1, r-1]; &#125; let [start, end] = [0, 0]; for (let center = 0; center &lt; s.length; center++) &#123; // 遍历中心点center let [l1, r1] = findLongestResByCenter(s, center, center); let [l2, r2] = findLongestResByCenter(s, center, center + 1); let [left, right] = r1 - l1 &gt; r2 - l2 ? [l1, r1] : [l2, r2]; if (right - left &gt; end - start) &#123; start = left; end = right; &#125; &#125; return s.substring(start, end+1);&#125;; 在该算法中，外层遍历中心点有一个循环，内层查找并验证子串有一个循环，因此时间复杂度成功地降到了O(n^2)，并且也未增加额外的存储空间。 暴力破解法 =&gt; 中心扩展法: 时间复杂度: O(n^3) =&gt; O(n^2); Manacher 算法在中心扩展算法中还存在可以优化的点： 是否可以解决回文串长度奇偶的问题，减少一轮循环； 已经判断过的回文串是否可以利用起来； 于是，Manacher算法诞生了。 关于Manacher算法网上各种详细的解释已经很多，这里笔者就不再赘述，只是阐释一下笔者自己的理解。 首先，解决回文串长度奇偶的问题。对于任意一个字符串，在其中和首尾插入字符串中并不存在的一个字符，例如#，无论原字符串长度奇偶，变换后都是偶数，于是”dabbac” 变成了 “#d#a#b#b#a#c#”，”dababac” 变成了 “#d#a#b#a#b#a#c#”。变化后的字符串并不影响之前的回文子串分布，并且在该变换后的字符串中存在的回文字符串一定是奇数长度的，即为 “#c#b#b#c#” 或者 “#c#a#c#” 这种形式。 然后，我们考虑将回文串查找过程中已经验证过的子串利用起来： 首先假设在计算过程中已经找到一个目前标杆回文子串flagStr，它的中心在原字符串索引为center, 它的右边界在原字符串索引为right，每当新的扩展中心点i超过right时，更新center为i，更新right为以i中心的最长回文串的右边界； 对于标杆回文子串flagStr，在flagStr的左半径如果存在回文子串preStr，假设其中心为preCenter，那么在其右半径一定也存在一个以preCenterMirror为中心的回文子串preStrMirror, 其中 preCenterMirror 为 preCenter 对于 center 的镜像点； 所以在center之后的点就可以省去重复遍历以preCenterMirror的为中心的回文串，假设preStr中心到边界的长度为R（即回文串的半径）。那么对于preCenterMirror的回文串，只需要: 当 preCenterMirror + R &gt; right，从right开始扩展回文串； 当 preCenterMirror + R &lt; right, 从 preCenterMirror + R 开始扩展回文串； 综上所述，我们需要在中心扩展法的基础上增加两个操作： 在原字符串中各字符间即首尾插入’#’以使原字符串始终为偶数; 用一个与原字符串同样长度的数组p记录各个字符点为中心点的最长回文串信息; 存储目前最长回文串的中心点及右边界; 为了避免在转换后字符串计算中遍历越界，故在首尾加入不同的两个字符’$’ 和 ‘@’; 由于转换后的字符串是原字符串长度的两倍，最后找出的最长回文子串的中心索引maxCenter长度maxLen，转换为原字符串中，中心索引为Math.floor(maxCenter / 2)，长度为maxLen / 2。 根据以上思路，start coding: 1234567891011121314151617181920212223242526272829303132333435363738function longestPalindrome (s) &#123; let t = s.split('').join('#'); t = `$#$&#123;t&#125;#@`; let n = t.length; // 数组p用来记录已经扩展成功的子串中心点以及半径，p[i] = R，i为中心点索引，R为回文串半径 let p = new Array(n).fill(0); let [center, right] = [0, 0]; let maxLen = 0; let maxCenter = 0; for (let i = 1; i &lt; n - 1; i++) &#123; if (right &gt; i) &#123; // 如果目前扩展的中心点在目前已计算出的标杆回文子串之内，寻找以i为中心的最长回文串的起始半径 // 因为center始终小于等于i, 所以i一定是大于 2*right - center的，即如果 i &lt; right, 那么 i 一定在目前标杆回文子串之内 p[i] = Math.min(right - i, p[2 * center - i]); &#125; while (t[i + p[i] + 1] == t[i - p[i] - 1]) &#123; // 中心扩展法计算回文串半径 p[i]++; &#125; if (i + p[i] &gt; right) &#123; // 当新的回文串边界超过了目前的标杆回文子串边界，更新标杆回文子串信息 center = i; right = i + p[i]; &#125; if (p[i] &gt; maxLen) &#123; // 更新最长回文串的信息 maxLen = p[i]; maxCenter = i; &#125; &#125; let start = parseInt((maxCenter - maxLen) / 2); return s.substring(start, start + maxLen);&#125;; 在Manacher算法中，我们使用了一个与原字符串两倍长度的数组存储回文子串信息，并以此减少了中心扩展半径的循环，优化结果（相较于中心扩展法）： 时间复杂度: O(n^2) =&gt; O(n); 空间复杂度: O(1) =&gt; O(n);","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://shadowwood.me/categories/Algorithm/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://shadowwood.me/tags/javascript/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://shadowwood.me/tags/Algorithm/"}]},{"title":"express源码分析","slug":"2016-08-27-express-origin-code-analysis","date":"2016-08-27T13:00:00.000Z","updated":"2018-04-19T12:05:15.903Z","comments":true,"path":"2016/08/27/2016-08-27-express-origin-code-analysis/","link":"","permalink":"https://shadowwood.me/2016/08/27/2016-08-27-express-origin-code-analysis/","excerpt":"前言express是node.js的一个轻量级后端框架，本文将对express的源码实现逻辑及主要服务的实现方式做一些分析 基本结构直接npm install express，可以看到express的包结构如下： ├── lib │ ├── middleware │ │ ├── init.js │ │ └── query.js │ ├── router │ │ ├── index.js │ │ ├── layer.js │ │ └── route.js │ ├── application.js │ ├── express.js │ ├── request.js │ ├── response.js │ ├── utils.js │ └── view.js ├── History.md ├── index.js ├── LICENSE ├── package.json └── Readme.md express模块的入口是 index.js，该文件中又引入了./lib/express.js，并将其用module.exports导出。","text":"前言express是node.js的一个轻量级后端框架，本文将对express的源码实现逻辑及主要服务的实现方式做一些分析 基本结构直接npm install express，可以看到express的包结构如下： ├── lib │ ├── middleware │ │ ├── init.js │ │ └── query.js │ ├── router │ │ ├── index.js │ │ ├── layer.js │ │ └── route.js │ ├── application.js │ ├── express.js │ ├── request.js │ ├── response.js │ ├── utils.js │ └── view.js ├── History.md ├── index.js ├── LICENSE ├── package.json └── Readme.md express模块的入口是 index.js，该文件中又引入了./lib/express.js，并将其用module.exports导出。 express.jslib/express.js是对express所有定义及功能模块的整合，该文件的开头如下： 12345678910111213141516171819202122232425262728293031var EventEmitter = require('events').EventEmitter;var mixin = require('merge-descriptors');var proto = require('./application');var Route = require('./router/route');var Router = require('./router');var req = require('./request');var res = require('./response');exports = module.exports = createApplication;function createApplication() &#123; var app = function(req, res, next) &#123; app.handle(req, res, next); &#125;; mixin(app, EventEmitter.prototype, false); mixin(app, proto, false); // expose the prototype that will get set on requests app.request = Object.create(req, &#123; app: &#123; configurable: true, enumerable: true, writable: true, value: app &#125; &#125;) // expose the prototype that will get set on responses app.response = Object.create(res, &#123; app: &#123; configurable: true, enumerable: true, writable: true, value: app &#125; &#125;) app.init(); return app;&#125; 文件一开始便引入了一些基础模块，基本来说根据这些模块的引入基本对express结构基本有一些理解了，之后的分析思路也会沿着这些引入的文件来进行。先大概介绍下这些模块做了哪些事情： EventEmitter: node.js的events模块 mixin: 用来合并对象的工具 proto: express应用的原型对象，在application.js里详细定义 Route: 定义最基本Route对象，包括app.post,app.all等以及Router对象的http方法都是从这里继承的 Router: 完整的Router对象，继承了Route的http方法，也集合了./router/layer.js下的路由初始化方法及路由处理方法，相当于是路由功能的整合 req: request对象 res: response对象 在引入了这些模块之后，就有了整个express的应用创建方法createApplication，也相当于是express的一个main函数。在createApplication函数中一开始就把需要返回的值app定义为一个函数，该函数有req, res, next三个参数，这不得不使人联想起app.get(‘/‘, function(req, res, next) {})里的req,res,next。在这个函数的内部则直接调用app的handle方法，并将req,res,next作为参数传入其中。app.handle这个方法是在./application中定义的并通过mixin将该方法合并到app对象上。 123456789101112131415161718app.handle = function handle(req, res, callback) &#123; var router = this._router; // final handler var done = callback || finalhandler(req, res, &#123; env: this.get('env'), onerror: logerror.bind(this) &#125;); // no routes if (!router) &#123; debug('no routes defined on app'); done(); return; &#125; router.handle(req, res, done);&#125;; 该方法的作用是将res, res逐级分发到express应用每个路由中，以便执行各个路由相匹配的操作。其实这个函数最关键的部分是在router.handle(req, res, done)这个方法的执行上，这是真正的路由分发执行操作，在./router/index.js里面定义，之后会对这部分进行分析讲解。 接着createApplication里的操作。在定义了app之后，执行了两个mixin方法，分别将 EventEmitter 和 ./application.js 中的属性和方法合并到app之中。 在 mixin 之后，createApplicaion 又使用了对象字面量的定义方法，定义了app.request和app.response对象，分别以 ./request.js 和 ./response.js为原型对象，并赋值app属性且指向app本身(这里是为了在之后的response对象或request对象中，能够使用this.app访问已经创建的express实例)。 然后就是执行app.init()，这个init()方法也是在./application.js中定义的，用来初始化express应用的设置 1234567app.init = function init() &#123; this.cache = &#123;&#125;; this.engines = &#123;&#125;; this.settings = &#123;&#125;; this.defaultConfiguration();&#125;; 在createApplicaion的最后返回组建好的app对象。 在createApplicaion之后，便是一些公共API的导出：1234567891011121314151617exports.application = proto;exports.request = req;exports.response = res;/*** Expose constructors.*/exports.Route = Route;exports.Router = Router;/*** Expose middleware*/exports.query = require('./middleware/query');exports.static = require('serve-static'); 对于这些公共api模块的功能和作用也不多说了，express的文档有相应的说明。 在./express.js的最后，遍历了一个数组： 12345678910111213141516171819202122232425262728[ 'json', 'urlencoded', 'bodyParser', 'compress', 'cookieSession', 'session', 'logger', 'cookieParser', 'favicon', 'responseTime', 'errorHandler', 'timeout', 'methodOverride', 'vhost', 'csrf', 'directory', 'limit', 'multipart', 'staticCache',].forEach(function (name) &#123; Object.defineProperty(exports, name, &#123; get: function () &#123; throw new Error('Most middleware (like ' + name + ') is no longer bundled with Express and must be installed separately. Please see https://github.com/senchalabs/connect#middleware.'); &#125;, configurable: true &#125;);&#125;); 这是因为express 4.x之后，很多中间件依赖没有在express内部导入了，但是express有时会用到这些中间件，这里是一个中间件检测，告诉开发者数组内的中间件需要从外部install进来。 router./router文件夹下包括三个文件： layer.js：定义中间件的基本数据结构 route.js：定义express的路由中间件Route; index.js：定义一个中间件容器，也就是Router对象，用来存放路由中间件(Route)以及其他功能中间件 Router 和 Route 的区别：Router可以看作是一个中间件容器，不仅可以存放路由中间件（Route），还可以存放其他中间件；而Route仅仅是路由中间件，封装了路由信息。Router和Route都各自维护了一个stack数组，该数组就是用来存放中间件和路由的。 layer.js首先来看layer.js中对于中间件的初始定义： 1234567891011121314151617181920var pathRegexp = require('path-to-regxp');function Layer(path, options, fn) &#123; if (!(this instanceof Layer)) &#123; return new Layer(path, options, fn) &#125; debug('new %s', path); var opts = options || &#123;&#125;; this.handle = fn; this.name = fn.name || '&lt;anonymous&gt;'; this.params = undefined; this.path = undefined; this.regexp = pathRegexp(path, this.keys = [], opts); if (path === '/' &amp;&amp; opts.end === false) &#123; this.regexp.fast_slash = true; &#125;&#125; path参数不用多说，就是传入的url字符串，这里使用了path-to-regexp这个库，用来匹配url字符串，options是path-to-regexp需要的配置参数，即为 {sensitive: Boolean, stric: Boolean, end: Boolean}。npm上有该库的详细使用说明，这里就不再讲解了。fn也就是中间件里的回调处理函数，在Layer初始化的时候将它赋值给了自己的handle属性。 之后Layer还定义了三个操作方法：handle_error, handle_request, match。 handle_error就是定义的express应用中的错误处理部分，例如app.use(fuction(err, req, res, next){})最后就会执行到这里。handle_request定义的就是express应用中的路由中间件请求处理函数，也就是例如app.get(‘/test’, function(req, res, next){})的操作最后的执行位置。match定义的是匹配path参数的操作，使用path-to-regexp的操作方法，例如在请求过程中/foo/23与就会和之前定义的/foo/:id相匹配，并最终将对应的23赋值req.params.id，这一部分的操作需要结合path-to-regexp的操作方法去了解。 整个Layer的定义其实并不复杂，它定义了中间件的基本数据结构，是后面Router和Route对象实现的基础。 route.js同样，先从Route对象的初始化入手： 12345678function Route(path) &#123; this.path = path; this.stack = []; debug('new %s', path); this.methods = &#123;&#125;;&#125; path参数不用多说，stack是一个存放layer组件的数组，methods是存放HTTP方法的Object，例如{‘get’: true, ‘post’: true}，即表示该Route中间件只能接受get和post方法。 紧接着Route通过原型链的方式定义了两个与methods紧密相关的方法： _handles_method: 判断Route对象中是否存在method(传入参数)方法，并且如果method值为head，当作get方法处理； _options：返回Route对象的methods值，并且如果存在get，则再添加一个head值。 然后就是比较重要的部分，中间件的派发操作： 12345678910111213141516171819202122232425262728293031323334353637Route.prototype.dispatch = function dispatch(req, res, done) &#123; var idx = 0; var stack = this.stack; if (stack.length === 0) &#123; return done(); &#125; var method = req.method.toLowerCase(); if (method === 'head' &amp;&amp; !this.methods['head']) &#123; method = 'get'; &#125; req.route = this; next(); function next(err) &#123; if (err &amp;&amp; err === 'route') &#123; return done(); &#125; var layer = stack[idx++]; if (!layer) &#123; return done(err); &#125; if (layer.method &amp;&amp; layer.method !== method) &#123; return next(err); &#125; if (err) &#123; layer.handle_error(err, req, res, next); &#125; else &#123; layer.handle_request(req, res, next); &#125; &#125;&#125;; 在知道了layer和stack这两个事物的基础上，这个函数的操作流程就很好理解了，其实就是通过函数递归的方法，对Route对象的stack按插入顺序进行遍历，然后依次执行stack里的layer的过程。当然，首先req.method也就是请求的http方法必须在Route对象中的methods之中。 最后就是定义如何调用Route对应的HTTP方法,也就是router.get,router.post等最终执行的地方 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647Route.prototype.all = function all() &#123; var handles = flatten(slice.call(arguments)); for (var i = 0; i &lt; handles.length; i++) &#123; var handle = handles[i]; if (typeof handle !== 'function') &#123; var type = toString.call(handle); var msg = 'Route.all() requires callback functions but got a ' + type; throw new TypeError(msg); &#125; var layer = Layer('/', &#123;&#125;, handle); layer.method = undefined; this.methods._all = true; this.stack.push(layer); &#125; return this;&#125;;methods.forEach(function(method)&#123; Route.prototype[method] = function()&#123; var handles = flatten(slice.call(arguments)); for (var i = 0; i &lt; handles.length; i++) &#123; var handle = handles[i]; if (typeof handle !== 'function') &#123; var type = toString.call(handle); var msg = 'Route.' + method + '() requires callback functions but got a ' + type; throw new Error(msg); &#125; debug('%s %s', method, this.path); var layer = Layer('/', &#123;&#125;, handle); layer.method = method; this.methods[method] = true; this.stack.push(layer); &#125; return this; &#125;;&#125;); 两个代码块一个是定义了Route.all,一个是通过遍历methods(require(‘methods’)，存储了各种HTTP请求方法)将其中的元素赋值到成Route对象的属性，也就有了Route.get,Route.post等方法。其实这两个代码块其中的执行流程都大同小异。在这里需要注意的是定义Route.method(这里method指代all,get,post等)时，其中第一行代码 1var handles = flatten(slice.call(arguments)); 这里的handles就是app.get(‘/path’, fn1, fn2, fn3)中的fn1,fn2,fn3等，也就是中间件的回调函数。但是如果这样使用，有人会问不应该是slice.call(arguments, 1)，也就是从第二个参数开始截取吗？(slice 是 Array.prototype.slice，在route.js开头定义的)刚开始看到这里的时候，笔者也有这个疑问，后来在index.js里面，也就是定义Router对象的地方，找到这么一段代码： 1234567891011121314151617181920212223proto.route = function route(path) &#123; var route = new Route(path); var layer = new Layer(path, &#123; sensitive: this.caseSensitive, strict: this.strict, end: true &#125;, route.dispatch.bind(route)); layer.route = route; this.stack.push(layer); return route;&#125;;// create Router#VERB functionsmethods.concat('all').forEach(function(method)&#123; proto[method] = function(path)&#123; var route = this.route(path) route[method].apply(route, slice.call(arguments, 1)); return this; &#125;;&#125;); 这里可以看出Route是被放在了Router的stack里的layer.route，然后在调用类似Router[method](path, fn1, fn2)的时候，已经将其中path提取出来，并且直接通过调用this.route(path)赋值到Route中的path属性，之后将fn1,fn2通过slice.call(arguments,1)的方式截取出来，使用route[method].apply调用到Route.method方法。所以在Route.method调用的时候，其arguments已经是回调函数fn1，fn2等的数组了。 OK，解决了这个疑问，继续下一个重点，可以看见在Route.method的定义中，最终都返回了this，加上之前对于arguments的处理，就形成了路由中间件的灵活调用方法： 12345router.get('/path', fn1, fn2, fn3);router.get('/path', [fn1, [fn2, [fn3]]]);router.get('/path', fn1).get('/path', fn2).get('/path', fn3); 这三个最终实现的结果是一样的，第一个和第二个没有什么区别，第三个有些许不一样，第一个和第二个在Router中’fn1,fn2,fn3’都是在同一个layer.route之中，而第三个则是在不同的layer.route之中。第一个和第二个是通过遍历Route的stack来找到fn进行执行，而第三个是遍历Router的stack来找到fn进行执行。简单来说就是一个放在外层的stack，一个放在内层的stack。 其实在route.js这部分必须要结合index.js来看，不然对于一些实现方法不是很好理解。 index.js老规矩，还是先从导出对象的基本定义开始。 12345678910111213141516171819var proto = module.exports = function(options) &#123; var opts = options || &#123;&#125;; function router(req, res, next) &#123; router.handle(req, res, next); &#125; // mixin Router class functions setPrototypeOf(router, proto); router.params = &#123;&#125;; router._params = []; router.caseSensitive = opts.caseSensitive; router.mergeParams = opts.mergeParams; router.strict = opts.strict; router.stack = []; return router;&#125;; 这里的初始化定义应该不难看懂，options参数就是pathRegexp要求的三个配置参数caseSensitive,mergeParams,strict。router.stack前面也解释得比较多了，这里也不再赘述。router.params和router._params是定义app.params(param, fn)中会使用到存储对象。需要注意的是Router最终返回的是 router.handle(req,res,next)的执行函数，router.handle是定义的Router中的路由派发操作，类似Route.dispatch，之后这里会详细解释。 在这之后在Router对象上定义了param(name, fn)方法，这其实就是app.param(name, fn)定义的部分，这部分会在appliction.js绑定到app.param上，也就成了express文档里的app.param。这部分没有什么难以理解的地方，结合文档看基本可以理解，所以这里就跳过proto.param(name, fn)。 之后就是在Router的初始化里提到过的router.handle的定义： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051proto.handle = function handle(req, res, out) &#123; var self = this; debug('dispatching %s %s', req.method, req.url); var search = 1 + req.url.indexOf('?'); var pathlength = search ? search - 1 : req.url.length; var fqdn = req.url[0] !== '/' &amp;&amp; 1 + req.url.substr(0, pathlength).indexOf('://'); var protohost = fqdn ? req.url.substr(0, req.url.indexOf('/', 2 + fqdn)) : ''; var idx = 0; var removed = ''; var slashAdded = false; var paramcalled = &#123;&#125;; // store options for OPTIONS request // only used if OPTIONS request var options = []; // middleware and routes var stack = self.stack; // manage inter-router variables var parentParams = req.params; var parentUrl = req.baseUrl || ''; var done = restore(out, req, 'baseUrl', 'next', 'params'); // setup next layer req.next = next; // for options requests, respond with a default if nothing else responds if (req.method === 'OPTIONS') &#123; done = wrap(done, function(old, err) &#123; if (err || options.length === 0) return old(err); sendOptionsResponse(res, options, old); &#125;); &#125; // setup basic req values req.baseUrl = parentUrl; req.originalUrl = req.originalUrl || req.url; next(); function next(err) &#123; /**next 定义，暂时省略 **/ &#125; function trim_prefix(layer, layerError, layerPath, path) &#123; /**暂时省略 **/ &#125;&#125; 因为这部分加上内部定义的函数的话，代码量比较多，一下贴出来不太容易理清思路，所以先将next和trim_prefix函数省略(trim_prefix是在next内部调用的)，先看看handle大概做了一件什么事情。之前也说过router.handle是派发req和res到每个路由中间件的操作，联系之前提到的Route中的dispatch方法是通过函数调用的方法来遍历stack的中间件实现的req和res的派发，所以这里也是用了同样的操作：“通过递归调用next来实现路由派发”。但是在调用next()之前，router.handle对req.url也就是原始的url进行了处理，把请求协议和search参数以及host都提取了出来，所以可以理解为在派发路由前，先对url做了一个预处理操作。 接下来就是仔细看一下看next函数是具体定义了一个怎么样的操作： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105function next(err) &#123; var layerError = err === 'route' ? null : err; // remove added slash if (slashAdded) &#123; req.url = req.url.substr(1); slashAdded = false; &#125; // restore altered req.url if (removed.length !== 0) &#123; req.baseUrl = parentUrl; req.url = protohost + removed + req.url.substr(protohost.length); removed = ''; &#125; // no more matching layers if (idx &gt;= stack.length) &#123; setImmediate(done, layerError); return; &#125; // get pathname of request var path = getPathname(req); if (path == null) &#123; return done(layerError); &#125; // find next matching layer var layer; var match; var route; while (match !== true &amp;&amp; idx &lt; stack.length) &#123; layer = stack[idx++]; match = matchLayer(layer, path); route = layer.route; if (typeof match !== 'boolean') &#123; // hold on to layerError layerError = layerError || match; &#125; if (match !== true) &#123; continue; &#125; if (!route) &#123; // process non-route handlers normally continue; &#125; if (layerError) &#123; // routes do not match with a pending error match = false; continue; &#125; var method = req.method; var has_method = route._handles_method(method); // build up automatic options response if (!has_method &amp;&amp; method === 'OPTIONS') &#123; appendMethods(options, route._options()); &#125; // don't even bother matching route if (!has_method &amp;&amp; method !== 'HEAD') &#123; match = false; continue; &#125; &#125; // no match if (match !== true) &#123; return done(layerError); &#125; // store route for dispatch on change if (route) &#123; req.route = route; &#125; // Capture one-time layer values req.params = self.mergeParams ? mergeParams(layer.params, parentParams) : layer.params; var layerPath = layer.path; // this should be done for the layer self.process_params(layer, paramcalled, req, res, function (err) &#123; if (err) &#123; return next(layerError || err); &#125; if (route) &#123; return layer.handle_request(req, res, next); &#125; trim_prefix(layer, layerError, layerPath, path); &#125;);&#125; 在这里主要关注一下stack的遍历操作。在next之中stack的遍历先是通过while循环判断match值来确定是否找到匹配的layer, match是通过调用matchLayer返回结果，该方法定义为： 1234567function matchLayer(layer, path) &#123; try &#123; return layer.match(path); &#125; catch(err) &#123; return err; &#125;&#125; 其实就是调用layer.match，只是加了个try catch而已。 如果while循环如果找到了匹配的layer，那么会就会调用proto.process_params的方法，也就是self.process_params()这部操作； proto.process_params的源码这里就不贴出来了，了解一下操作流程就好。这个方法需要对应proto.param来理解，其实就是查询并调用proto.param里面定义且匹配的与req.param绑定的function，这些回调函数都是存储在proto.params里面的，所以这里就又会有一个通过函数递归的遍历操作。在遍历完了之后就是调用 1234567891011function (err) &#123; if (err) &#123; return next(layerError || err); &#125; if (route) &#123; return layer.handle_request(req, res, next); &#125; trim_prefix(layer, layerError, layerPath, path);&#125; 如果layer.route是存在的，结合之前分析的Layer和Route以及在Route的分析中提前提到这部分后面定义的Router.route，也就是： 1234567891011121314proto.route = function route(path) &#123; var route = new Route(path); var layer = new Layer(path, &#123; sensitive: this.caseSensitive, strict: this.strict, end: true &#125;, route.dispatch.bind(route)); layer.route = route; this.stack.push(layer); return route;&#125;; layer.handle_request会执行layer.route的dispatch操作，也就是在Route中派发路由最终执行到在express中定义的对应的路由操作函数，之后又执行next()就又到了这里的proto.stack中的下一个遍历操作。但是如果layer.route不存在，说明这只是一个中间件而不是路由中间件，也就是用route.use定义的中间件，所以就调用trim_prefix方法来执行路由中间件： 12345678910111213141516171819202122232425262728293031function trim_prefix(layer, layerError, layerPath, path) &#123; var c = path[layerPath.length]; if (c &amp;&amp; '/' !== c &amp;&amp; '.' !== c) return next(layerError); // Trim off the part of the url that matches the route // middleware (.use stuff) needs to have the path stripped if (layerPath.length !== 0) &#123; debug('trim prefix (%s) from url %s', layerPath, req.url); removed = layerPath; req.url = protohost + req.url.substr(protohost.length + removed.length); // Ensure leading slash if (!fqdn &amp;&amp; req.url[0] !== '/') &#123; req.url = '/' + req.url; slashAdded = true; &#125; // Setup base URL (no trailing slash) req.baseUrl = parentUrl + (removed[removed.length - 1] === '/' ? removed.substring(0, removed.length - 1) : removed); &#125; debug('%s %s : %s', layer.name, layerPath, req.originalUrl); if (layerError) &#123; layer.handle_error(layerError, req, res, next); &#125; else &#123; layer.handle_request(req, res, next); &#125;&#125; 这个方法是在proto.handle里定义，和next同级。 OK，这里再回到while，如果while循环没有找到匹配的layer就进行收尾工作，要么就根据layerError也就是next(err)中的err参数判断是否已经匹配到结果正常首尾，或者就是404没找到匹配。 分析到这里，这里使用两张图对上面的分析进行一个整理。 首先是layer,Route和Router这三者的关系（原图片来自文章从express源码中探析其路由机制） 然后是proto.handle的一个执行流程： 有了这两张图，再配合之前的文字描述，应该对路由这部分的处理不会有什么问题了。 request 和 response先说request.js，这里是定义app.method(path, function(req, res, next) {}) 中 req对象的地方，首先先看req对象初始化 var req = Object.create(http.IncommingMessage.prototype); req是以http.IncommingMessage的原型创建的对象，也就是说http.IncommingMessage该有的事件和方法，req都是有的，并且req也是一个Readable Stream，如果要具体了解，可以去看看http.IncommingMessage的文档 在这个文件里面express文档中关于req的方法都在这里有对应的定义，并且也不难读，所以这里也就不再多说。 值得一提的是req.params, req.query和req.body都不是在这里初始化和定义的： req.params: 之前在介绍layer.js的时候提到过，req.params是在中间件匹配的过程中生成的，这个params对象先是在layer中初始化并且通过path-to-regexp匹配生成键值对，然后再router/index.js定义Router的handle方法的里，将params值赋给req: 123456789proto.handle = function handle(req, res, out) &#123; /* 省略 */ // Capture one-time layer values req.params = self.mergeParams ? mergeParams(layer.params, parentParams) : layer.params; /* 省略 */&#125;; req.query: 这里的可以去看middleware/query.js 中，首先这里定义了query函数中间件，然后在application.js里面定义的lazyrouter方法里，以router.use方法调用这个query函数中间件: 1234567891011app.lazyrouter = function lazyrouter() &#123; if (!this._router) &#123; this._router = new Router(&#123; caseSensitive: this.enabled('case sensitive routing'), strict: this.enabled('strict routing') &#125;); this._router.use(query(this.get('query parser fn'))); this._router.use(middleware.init(this)); &#125;&#125;; 而这个lazyrouter方法呢只要是使用了app.use或者app.get, app.post等都会调用，所以req.query是在这个时候生成的。 req.body: 现在这个对象已经不再express处理了，主要是因为body-parser已经从express里依赖的包里面独立出去了，所以这部分的处理可以去看body-parser这个包，当然req.body也是在中间件中生成的； 然后我们再来看response.js，这里是定义app.method(path, function(req, res, next) {})中的res的地方，首先是res的初始化: 1var res = Object.create(http.ServerResponse.prototype); res是以http.ServerResponse的原型创建的对象，也就是说http.ServerResponse的事件和方法基本也适用于它，并且也是一个Writable Stream对象。res相对于req就要简单一些，在express文档里面提到的方法在这里都是在这里定义的，所以也不再多说了。 applicationapplication.js, 这里就是定义初始化express应用的地方，也就是express.js中的express应用的proto定义的地方，里面也定义了express()返回的对象里面可使用的各个方法，阅读起来难度也不大。 总的来说application.js算是一个集大成所在的地方了，这里也是express应用对象定义的入口，在分析完各个部分之后，再在application这里看一遍整理一下，应该就比较清楚整个express是什么样的结构了。 本来这里有一个lazyrouter方法应该说一下，但是在分析req.query的时候已经提到过了，这里就不再赘述了。 从请求到响应以创建一个express服务为例 123456789101112131415161718192021222324252627282930const responseTime = require('response-time');const cookieParser = require('cookie-parser');const bodyParser = require('body-parser');const expressSession = require('express-session');const express = require('express');const compression = require('compression');const http = require('http');const path = require('path');const router = require('../routes');const app = express();const resolve = file =&gt; path.resolve(__dirname, file);app.use(compression());app.use(responseTime());app.use(bodyParser.json(&#123;limit: '10mb'&#125;));app.use(bodyParser.urlencoded(&#123;limit: '10mb', parameterLimit: 100000, extended: false&#125;));app.use(cookieParser());app.use(router);app.use(function(req, res, next) &#123; next(&#123;status: 'pageNotFound', code: 404&#125;);&#125;);app.listen(8000, function() &#123; console.log('start up!');&#125;); app.listen方法在application.js里面有定义： 1234app.listen = function listen() &#123; var server = http.createServer(this); return server.listen.apply(server, arguments);&#125;; 关于http.createServer在官方文档里有说明： 123456789http.createServer([requestListener])Added in: v0.1.13requestListener &lt;Function&gt;Returns: &lt;http.Server&gt;Returns a new instance of http.Server.The requestListener is a function which is automatically added to the &apos;request&apos; event. 而app(req, res, next)的执行时直接调用的app.handle(req, res, next)方法，也就是在express.js中的createApplication中定义的: 1234567function createApplication() &#123; var app = function(req, res, next) &#123; app.handle(req, res, next); &#125;; /* 省略 */&#125; app.handle()一执行就是直接按照之前app中定义好的中间件顺序进行匹配并且执行了，整个express服务也就这样开始一步一步处理请求，直到最后res对象发送请求到客户端。 总结这篇文章由于笔者的拖延症，整整拖了半年左右才写完，不过最重要的部分也就是中间件那部分的内容是一开始就完成了的。 由于完成的事件跨度较大，所以express的代码有部分的更新变动可能会导致此文章贴出的源码前后会有一些差异，不过总的实现方法和思想倒是没啥变化。 express是一个非常轻量的框架，用来实现一些微服务特别便利，但是如果要用来做企业级的应用和服务的话，就需要制定许多约束或者说是规范。笔者也正在这方面努力踩坑=。=。","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://shadowwood.me/categories/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://shadowwood.me/tags/javascript/"},{"name":"node.js","slug":"node-js","permalink":"https://shadowwood.me/tags/node-js/"},{"name":"express","slug":"express","permalink":"https://shadowwood.me/tags/express/"}]},{"title":"Promise的简单实现","slug":"2016-08-12-acherive-promise","date":"2016-08-12T02:08:00.000Z","updated":"2018-04-19T12:06:26.859Z","comments":true,"path":"2016/08/12/2016-08-12-acherive-promise/","link":"","permalink":"https://shadowwood.me/2016/08/12/2016-08-12-acherive-promise/","excerpt":"前言Promise是js的一个异步流程控制标准，是为了解决js中异步回调过多导致的代码结构混乱的问题。Promise标准已经被写入了ES6的语法中，ES6已经有了原生的Promise对象。之前对async和promise的使用做了一个简单的对比，为了更好的理解Promise对异步回调的一个控制流程，这次根据Promise/A+规范实现一个简单的Promise。","text":"前言Promise是js的一个异步流程控制标准，是为了解决js中异步回调过多导致的代码结构混乱的问题。Promise标准已经被写入了ES6的语法中，ES6已经有了原生的Promise对象。之前对async和promise的使用做了一个简单的对比，为了更好的理解Promise对异步回调的一个控制流程，这次根据Promise/A+规范实现一个简单的Promise。 Promise/A+Promise/A+是一个开放、健全且通用的Javascript Promise标准，是由Javascript的开发者制定的，以供其他开发者参考。 Promise/A+英文原文 Promise/A+中文解读 上面是关于Promise/A+规范的资料，这里就不再对Promise/A+规范做进一步的解读了。 初始化Promise对象首先定义一个Promise对象： function Promise(fn) { var __self = { status: &apos;Pending&apos;, value: undefined, options: [&apos;Pending&apos;, &apos;Resolved&apos;, &apos;Rejected&apos;] } } 在这个Promise对象之中，定义了一个私有变量__self: __self.status: 该值用来存储该Promise对象当前的状态 __self.value: 该值用来存储Promise的终值(resolved时的value)或者拒绝的原因(rejected时的reason) __self.options: 该值为三个状态值的数组 因为Promise/A+中规定，Promise对象状态一旦处于resolved或者rejected，其状态和值便不能更改，所以其状态值和终值必须存储在私有变量中，防止外部对其进行操作更改。 但是这些私有变量也会涉及到值的更改，而且这些更改操作不一定在对象内部定义。所以在Promise对象定义的时候还需要定义一些set和get方法： function Promise(fn) { var __self = { status: &apos;Pending&apos;, value: undefined, options: [&apos;Pending&apos;, &apos;Resolved&apos;, &apos;Rejected&apos;] } var self = this; self.__getStatus = function () { return __self.status } self.__setStatus = function (val) { var index = __self.options.indexOf(val); if (index === -1 || __self.status === &apos;Resolved&apos; || __self.status === &apos;Rejected&apos;) { return false; } __self.status = val; return true; } self.__getValue = function () { return __self.value } self.__setValue = function () { if (__self.status === &apos;Pending&apos;) { __self.value = val; return true; } else { return false; } } } 首先是status的get和set函数，get函数直接返回__self.status的值，而在set函数之中则需要加一些限制。在Promise/A+标准中规定状态(status)的更改只能是从pending到resolved或者rejected，当状态为resolved或者rejcted的时候，便不能再更改状态。 然后是value的get和set函数，get函数同理直接返回__self.value，而在set函数之中，要求只能是状态为pending的时候才能对值进行修改，否则修改无效。 resolve和reject在Promise对象实例化的时候，其参数函数中(例如的Promise对象参数fn)有两个参数: resolve和reject。这两个参数是Promise对象实例化执行结束时调用的回调函数： resolve(value): 在执行成功时调用，将Promise对象的状态修改为resolved并且终值修改为传入的value reject(err): 在执行成功时调用，将Promise对象的状态修改为rejected并且将拒绝原因修改为传入的err 这两个函数既可以定义在Promise对象外面，也可以定义在Promise对象里面。当定义的Promise对象外面的时在之后执行的时候需要使用.bind(this)方法将Promise对象的this传入，所以其最终结果和定义在内部没有多少差异，所以这里还是采用定义在内部的方式： function Promise(fn) { var __self = { status: &apos;Pending&apos;, value: undefined, options: [&apos;Pending&apos;, &apos;Resolved&apos;, &apos;Rejected&apos;] } var self = this; self.onResolvedCallback = []; // Promise resolved 的回调函数集 self.onRejectedCallback = []; // Promise rejected 的回调函数集 /*****此处省略了之前的status和value的set和get函数******/ function resovle (val) { self.__setValue(val); self.__setStatus(&apos;Fulfilled&apos;) for (var i = 0; i &lt; self.onResolvedCallback.length; i++) { self.onResolvedCallback[i](val); } } function reject (err) { if (!err) { return ; } self.__setValue(err); self.__setStatus(&apos;Rejected&apos;); for (var i = 0; i &lt; self.onRejectedCallback.length; i++) { self.onRejectedCallback[i](err); } } try { fn(resolve, reject) } catch (err) { reject(err) } } 注意这次加入了两个特别的值，onResolvedCallback 和 onRejectedCallback，分别用来存储 Promise 对象 revolved 和 rejected 时的回调函数。至于为什么需要使用这两个值以及这两个值实现了什么功能，这个在之后的构建.then方法的时候再详细解释。 其实resolve和reject两个操作流程基本是一致的，都进行了三步操作： 设置终值或拒绝原因; 修改状态为Resovled或 Rejected 遍历回调函数集并执行回调函数； 这两者操作的区别只在于状态值和回调函数集不同，所以这两个函数完全可以合并成一个操作函数。这里只是为了语义更清晰一点，这里还是决定分开写。之后直接执行Promise对象的fn参数函数，并且传入resovle 和 reject 当作fn的参数，之后在fn内部执行回调。注意，这里执行fn的时候必须使用try catch捕捉错误并执行reject，因为完全可能在fn的执行过程中出现错误，这一部分也需要在Promise对象里捕捉到。 这里的resolve和reject还存在一个缺陷，就是在遍历onRejectedCallback和onResolvedCallback的时候可能会花费较大部分的时间，所以应该采用异步的写法，即加入setTimeout将其操作流程改成异步的: function resovle (val) { setTimeout(function() { self.__setValue(val); self.__setStatus(&apos;Fulfilled&apos;) for (var i = 0; i &lt; self.onResolvedCallback.length; i++) { self.onResolvedCallback[i](val); } }) } function reject (err) { if (!err) { return ; } setTimeout(function() { self.__setValue(err); self.__setStatus(&apos;Rejected&apos;); for (var i = 0; i &lt; self.onRejectedCallback.length; i++) { self.onRejectedCallback[i](err); } }) } .then方法Promise的.then方法是Promise对象的核心部分之一，可以说这个链式法则是Promise广受推崇的一个重要原因吧。对于.then方法，有几个重点要特别注意: .then方法返回的是一个Promise对象； .then方法有两个参数onResolved和onRejected，分别为Promise状态为Resolved和Rejected时的回调函数； .then方法可以在Promise还未执行完成的时候就开始执行，也就是说当Promise为Pending状态的时候，.then方法也可以执行； 针对以上几个要点，这里先从调用.then方法时Promise已经Resovled来实现： Promise.prototype.then = function (onResolved, onRejected) { onResolved = typeof onResolved === &apos;function&apos; ? onResolved : function (v) { return v }; onRejected = typeof onRejected === &apos;function&apos; ? onRejected : function (e) { throw e }; var self = this; var status = self.__getStatus(); var value = self.__getValue(); if (status === &apos;Pending&apos;) { return new Promise(function (resolve, reject) { try { var x = onResolved(value); if (x instanceof Promise) { x.then(resolve, reject) } else { resolve(x) } } catch (e) { reject(e) } }) } } 首先判断传入的参数onResolved和onRejected是否是函数，如果不是则分别默认为 function (v) { return v } 和 function (e) { throw e }，以便实现值的穿透(后面详细介绍)。然后获取到当前Promise对象的status 和 value，并返回一个新的Promise对象，在新的Promise对象中，执行onResolved函数。之后判断onResolved函数的返回值是否为Promise对象，如果是Promise对象，直接调用其.then方法并传入resolve和reject做为其onResolved和onRejected参数，如果不是则直接执行resolve。在这个操作流程之中，需要使用try catch包装代码块并将捕捉到的错误传入reject执行，因为完全可能在执行onResolved的过程中出现错误而阻止后续代码的执行。 当执行.then方法时Promise对象状态为Rejected的时候操作流程基本一致，只是将onResovled替换成onRejected就行了。所以这里可以将生成新的Promise对象内部的操作流程写成一个新的函数： function thenDeal(fn, value, resolve, reject) { try { var x = fn(value); if (x instanceof Promise) { x.then(resolve, reject) } else { resolve(x) } } catch (e) { reject(e) } } 这个函数可以写在.then方法外面并直接调用： Promise.prototype.then = function (onResolved, onRejected) { onResolved = typeof onResolved === &apos;function&apos; ? onResolved : function (v) { return v }; onRejected = typeof onRejected === &apos;function&apos; ? onRejected : function (e) { throw e }; var self = this; var status = self.__getStatus(); var value = self.__getValue(); switch (status) { case &apos;Resolved&apos;: return new Promise(function (resolve, reject) { thenDeal(onResolved, value, resolve, reject) }) case &apos;Rejected&apos;: return new Promise(function (resolve, reject) { thenDeal(onRejected, value, resolve, reject) }) } } 接下来就是需要考虑当.then方法执行时，Promise对象还是Pending状态的情况了，这里就需要用到之前定义的回调函数集合onResolvedCallback和onRejectedCallback。其实思路也并不复杂，只是需要注意一些值的调用，先给出完整的实现方法： Promise.prototype.then = function (onResolved, onRejected) { onResolved = typeof onResolved === &apos;function&apos; ? onResolved : function (v) { return v }; onRejected = typeof onRejected === &apos;function&apos; ? onRejected : function (e) { throw e }; var self = this; var status = self.__getStatus(); var value = self.__getValue(); switch (status) { case &apos;Pending&apos;: return new Promise(function (resolve, reject) { self.onResolvedCallback.push(function () { thenDeal(onResolved, self.__getValue(), resolve, reject) }); self.onRejectedCallback.push(function () { thenDeal(onRejected, self.__getValue(), resolve, reject) }) }); case &apos;Revolved&apos;: return new Promise(function (resolve, reject) { thenDeal(onResolved, value, resolve, reject) }) case &apos;Rejected&apos;: return new Promise(function (resolve, reject) { thenDeal(onRejected, value, resolve, reject) }) } } function thenDeal(fn, value, resolve, reject) { try { var x = fn(value); if (x instanceof Promise) { x.then(resolve, reject) } else { resolve(x) } } catch (e) { reject(e) } } 在Pending状态的时候，因为完全不清楚Promise最终的执行结果是Resolved还是Rejected，所以需要把onResolved和onRejected分别弄进onResolvedCallback和onRejectedCallback里，以传入回调函数的形式最终在里面执行thenDeal。这里需要注意一个特别的点，那就是thenDeal的value参数(即Resolved时的value或Rejected时的reason)必须是实时的Promise对象的值，即Promise的终值或拒绝原因，这部分和之前的Resolved及Rejected状态时的处理方式不同。 .catch可以直接用.then方法来定义： Promise.prototype.catch = function(onRejected) { return this.then(null, onRejected) } 对于这两行代码： onResolved = typeof onResolved === &apos;function&apos; ? onResolved : function (v) { return v }; onRejected = typeof onRejected === &apos;function&apos; ? onRejected : function (e) { throw e }; 条件判断的作用就不解释了，至于为什么要有function (v) {return v}和function (e) {throw e}的默认值，是为了实现Promise .then方法的值传递。例如： var p = new Promise((resolve, reject) =&gt; resolve(1)); p.then() .then(v =&gt; { console.log(1); throw(2); }) .then() .catch(e =&gt; console.log(e)) 该代码的最终输出结果为 1 和 2。 Promise的解决过程在之前的.then方法实现里面的thenDeal方法是直接通过判断 x instanceof Promise来确实返回值是否是Promise对象，这种实现不符合Promise/A+规范的，并且无法和其他Promise交互。在 Promise/A+ 的2.3部分定义了Promise .then方法里的解决过程，并且阐述了thenable特性。原文翻译为： Promise解决过程是一个抽象的操作，其需输入一个promise和一个值，我们表示为 [[Resolve]](promise, x)，如果 x 有 then 方法且看上去像一个 Promise ，解决程序即尝试使 promise 接受 x 的状态；否则其用 x 的值来执行 promise。 根据这个标准，需要加入一个promiseResovle方法来实现Promise解决过程，首先先明确这个promiseResovle方法的在之前的Promise实现需要插入的位置： Promise.prototype.then = function (onResolved, onRejected) { onResolved = typeof onResolved === &apos;function&apos; ? onResolved : function (v) { return v }; onRejected = typeof onRejected === &apos;function&apos; ? onRejected : function (e) { throw e }; var self = this; var status = self.__getStatus(); var value = self.__getValue(); switch (status) { case &apos;Pending&apos;: return promise2 = new Promise(function (resolve, reject) { self.onResolvedCallback.push(function () { thenDeal(onResolved, self.__getValue(), resolve, reject, promise2) }); self.onRejectedCallback.push(function () { thenDeal(onRejected, self.__getValue(), resolve, reject, promise2) }) }); case &apos;Revolved&apos;: return promise2 = new Promise(function (resolve, reject) { setTimeout(function () { thenDeal(onResolved, value, resolve, reject, promise2) }) }) case &apos;Rejected&apos;: return promise2 = new Promise(function (resolve, reject) { setTimeout(function () { thenDeal(onRejected, value, resolve, reject, promise2) }) }) } } function thenDeal(fn, value, resolve, reject, promise) { try { var x= fn(value); promiseResovle(promise, x, resolve, reject); } catch (e) { reject(e) } } 相较于之前的代码，主要在thenDeal进行了修改，传入了即将返回的Promise对象promise2，并且将其传入promiseResovle中。promiseResovle的功能是对onResolved或者onRejected的返回值进行处理解决，使其能实现多种Promise的交互。 根据Promise/A+的规定，promiseResovle需要依次判断三种情况： 参数 x 与 参数 promise 相等时； 参数 x 为 Promise(即自己定义的Promise，不是通用的或者其他的Promise对象)； 参数 x 为对象或者函数； 下面依次实现着三种情况的判断和要求。 参数 x 与 参数 promise 相等Promise/A+中规定，当参数 x 与 参数 promise 相等时，以TypeError为reason拒绝执行promise，实现代码如下： function promiseResovle(promise, r, resolve, reject) { if (r === promise) { return reject(new TypeError(&apos;The promise has been circular used&apos;)) } } 参数 x 为 Promise接着当 x为Promise时： 如果 x 处于等待态， promise 需保持为等待态直至 x 被执行或拒绝 如果 x 处于执行态，用相同的值执行 promise 如果 x 处于拒绝态，用相同的据因拒绝 promise 接着之前的实现： function promiseResovle(promise, r, resolve, reject) { if (r === promise) { return reject(new TypeError(&apos;The promise has been circular used&apos;)) } if (r instanceof Promise) { var status = r.__getStatus(); if (status === &apos;Pending&apos;) { r.then(function(value) { promiseResovle(promise, value, resolve, reject) }, reject) } else { r.then(resolve, reject) } return ; } } 当 x 处于 Pending状态的时候，调用 x 的 .then 方法并在其中再次调用promiseResolve以待获取 x 的终值或拒因；当 x 处于 onRejected 或者 onResolved 的时候，就可以直接执行 x.then 并传入 resolve 和 reject 来执行 promise； 参数 x 为对象或者函数当 x 为对象或者函数的时候，Promise/A+规定操作方法及顺序如下： 把 x.then 赋值给 then 如果取 x.then 的值时抛出错误 e ，则以 e 为据因拒绝 promise 如果 then 是函数，将 x 作为函数的作用域 this 调用之。传递两个回调函数作为参数，第一个参数叫做 resolvePromise ，第二个参数叫做 rejectPromise: 如果 resolvePromise 以值 y 为参数被调用，则运行 [[Resolve]](promise, y) 如果 rejectPromise 以据因 r 为参数被调用，则以据因 r 拒绝 promise 如果 resolvePromise 和 rejectPromise 均被调用，或者被同一参数调用了多次，则优先采用首次调用并忽略剩下的调用 如果调用 then 方法抛出了异常 e： 如果 resolvePromise 或 rejectPromise 已经被调用，则忽略之 否则以 e 为据因拒绝 promise 如果 then 不是函数，以 x 为参数执行 promise 如果 x 不为对象或者函数，以 x 为参数执行 promise 根据上述的规定，加上之前的实现，最终promiseResolve的定义如下： function promiseResovle(promise, x, resolve, reject) { var then; var thenCalled = false; if (x === promise) { return reject(new TypeError(&apos;The promise has been circular used&apos;)) } if (x instanceof Promise) { var status = x.__getStatus(); if (status === &apos;Pending&apos;) { x.then(function(value) { promiseResovle(promise, value, resolve, reject) }, reject) } else { x.then(resolve, reject) } return ; } function resolvePromise(y) { if(thenCalled) return; thenCalled = true; promiseResolve(promise, y, resolve, reject) } function rejectPromise(r) { if (thenCalled) return; thenCalled = true; reject(r) } if(x !== null &amp;&amp; (typeof x === &apos;Object&apos; || typeof x === &apos;function&apos;)) { try { then = x.then; if (typeof then === &apos;function&apos;) { then.call(x, resolvePromise, rejectPromise) } else { resolve(x) } } catch (e) { reject(e) } } else { resolve(x) } } 完整版最后，贴出完整版的Promise实现： function Promise(fn) { var __self = { status: &apos;Pending&apos;, value: undefined, options: [&apos;Pending&apos;, &apos;Resolved&apos;, &apos;Rejected&apos;] } var self = this; self.onResolvedCallback = []; // Promise resolved 的回调函数集 self.onRejectedCallback = []; // Promise rejected 的回调函数集 /*****status和value的set和get函数******/ self.__getStatus = function () { return __self.status } self.__setStatus = function (val) { var index = __self.options.indexOf(val); if (index === -1 || __self.status === &apos;Resolved&apos; || __self.status === &apos;Rejected&apos;) { return false; } __self.status = val; return true; } self.__getValue = function () { return __self.value } self.__setValue = function () { if (__self.status === &apos;Pending&apos;) { __self.value = val; return true; } else { return false; } } /*********END**********/ /*******resolve 和 reject *******/ function resovle (val) { setTimeout(function() { self.__setValue(val); self.__setStatus(&apos;Fulfilled&apos;) for (var i = 0; i &lt; self.onResolvedCallback.length; i++) { self.onResolvedCallback[i](val); } }) } function reject (err) { if (!err) { return ; } setTimeout(function() { self.__setValue(err); self.__setStatus(&apos;Rejected&apos;); for (var i = 0; i &lt; self.onRejectedCallback.length; i++) { self.onRejectedCallback[i](err); } }) } /***********END**********/ try { fn(resolve, reject) } catch (err) { reject(err) } } Promise.prototype.then = function (onResolved, onRejected) { /*************定义回调函数集************/ onResolved = typeof onResolved === &apos;function&apos; ? onResolved : function (v) { return v }; onRejected = typeof onRejected === &apos;function&apos; ? onRejected : function (e) { throw e }; /************END************/ var self = this; var status = self.__getStatus(); var value = self.__getValue(); switch (status) { case &apos;Pending&apos;: return promise2 = new Promise(function (resolve, reject) { self.onResolvedCallback.push(function () { thenDeal(onResolved, self.__getValue(), resolve, reject, promise2) }); self.onRejectedCallback.push(function () { thenDeal(onRejected, self.__getValue(), resolve, reject, promise2) }) }); case &apos;Revolved&apos;: return promise2 = new Promise(function (resolve, reject) { setTimeout(function () { thenDeal(onResolved, value, resolve, reject, promise2) }) }) case &apos;Rejected&apos;: return promise2 = new Promise(function (resolve, reject) { setTimeout(function () { thenDeal(onRejected, value, resolve, reject, promise2) }) }) } } function thenDeal(fn, value, resolve, reject, promise) { try { var x= fn(value); promiseResovle(promise, x, resolve, reject); } catch (e) { reject(e) } } function promiseResovle(promise, x, resolve, reject) { var then; var thenCalled = false; if (x === promise) { return reject(new TypeError(&apos;The promise has been circular used&apos;)) } if (x instanceof Promise) { var status = x.__getStatus(); if (status === &apos;Pending&apos;) { x.then(function(value) { promiseResovle(promise, value, resolve, reject) }, reject) } else { x.then(resolve, reject) } return ; } function resolvePromise(y) { if(thenCalled) return; thenCalled = true; promiseResolve(promise, y, resolve, reject) } function rejectPromise(r) { if (thenCalled) return; thenCalled = true; reject(r) } if(x !== null &amp;&amp; (typeof x === &apos;Object&apos; || typeof x === &apos;function&apos;)) { try { then = x.then; if (typeof then === &apos;function&apos;) { then.call(x, resolvePromise, rejectPromise) } else { resolve(x) } } catch (e) { reject(e) } } else { resolve(x) } } Promise.prototype.catch = function (onRejected) { return this.then(null, onRejected) } module.exports = Promise; 参考文献:Promise/A+规范英文原文Promise/A+规范中文翻译剖析Promise内部结构","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://shadowwood.me/categories/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://shadowwood.me/tags/javascript/"},{"name":"node.js","slug":"node-js","permalink":"https://shadowwood.me/tags/node-js/"},{"name":"Promise","slug":"Promise","permalink":"https://shadowwood.me/tags/Promise/"}]},{"title":"浅谈js异步流程框架async与Promise的区别","slug":"2016-04-25-deference-between-async-and-promise","date":"2016-04-25T08:02:00.000Z","updated":"2018-04-19T12:06:26.859Z","comments":true,"path":"2016/04/25/2016-04-25-deference-between-async-and-promise/","link":"","permalink":"https://shadowwood.me/2016/04/25/2016-04-25-deference-between-async-and-promise/","excerpt":"前言在node.js中执行异步操作时，操作的结果并不是通过返回函数来反馈，而是通过将结果传入回调函数，由回调函数来处理运行结果。如果在一个程序之中，我们需要多数的异步I/O操作，那么我们的回调结构将会是一层套一层不断的嵌套下去形成”callback hell(回调地狱)”。虽然我们也可以通过声明函数的方法来简化回调结构并避免callback hell的产生，但是如果遇到一些比较复杂的依赖关系的话，可能依然会有一些问题。最近接触到node.js两个不同的异步模块async和Promise，给大家做一下对比和分享。","text":"前言在node.js中执行异步操作时，操作的结果并不是通过返回函数来反馈，而是通过将结果传入回调函数，由回调函数来处理运行结果。如果在一个程序之中，我们需要多数的异步I/O操作，那么我们的回调结构将会是一层套一层不断的嵌套下去形成”callback hell(回调地狱)”。虽然我们也可以通过声明函数的方法来简化回调结构并避免callback hell的产生，但是如果遇到一些比较复杂的依赖关系的话，可能依然会有一些问题。最近接触到node.js两个不同的异步模块async和Promise，给大家做一下对比和分享。 async 和 Promise简介async(github)是一个包含了许多js异步操作方法的node.js模块，其中共有70个函数，包括一些与数组类似的方法(map, each, filter, reduce…)，和一些异步流程方法(series, parallel, waterfall, …)。这些方法都必须要求在node环境在才能运行实现，并且运行结果都是传递到一个回调函数里，一般都是两个参数，一个参数是错误异常error，另一个是操作结果。 Promise应该算是一个异步操作标准。Promise被定义为一个对象，来传递异步操作的消息，它代表了某个未来才会知道的结果的事件，并且这个事件提供统一的API，可供进一步的处理；Promise对象有两个特点： 对象的状态不受外界影响； 对象的状态一旦改变便不会再变，并且任何时候都可以得到这个结果。 对于Promise的实现有很多js库，并且对于这些js库也有一套评价标准Promise/A+。本文介绍的Promise使用的bluebird(官方文档)这个库。 一个简单的异步实现我们来进行一个简单的操作：使用fs.readFile从read.txt里面读取文件内容，然后将读取的内容用writeFile写入write.txt。 不用async和Promisevar fs = require(&apos;fs&apos;); fs.readFile(&apos;./read.txt&apos;, (err, data) =&gt; { fs.writeFile(&apos;./write.txt&apos;, data, (err) =&gt; { console.log(&quot;end&quot;); }) }) asyncvar async = require(&apos;async&apos;); var fs = require(&apos;fs&apos;); async.waterfall([ callback =&gt; fs.readFile(&apos;./read.txt&apos;, (err, data) =&gt; { callback(null, data) }), (data, callback) =&gt; fs.writeFile(&apos;./write.txt&apos;, data, (err) =&gt; { callback(err) }) ], (err, r) =&gt; console.log(&quot;end&quot;)); Promisevar Promise = require(&apos;bluebird&apos;); var fs = require(&apos;fs&apos;); var promise = new Promise((resolve, reject) =&gt; { fs.readFile(&apos;./read.txt&apos;, (err, data) =&gt; { if(err) reject(err); resolve(data) }) }); promise.then((data) =&gt; { fs.writeFile(&apos;./write.txt&apos;, data, (err) =&gt; { console.log(&quot;end&quot;) }) }); 咋一看觉得不用async或者Promise好像结构还简单一些，那么如果我们是这样一个操作流程: function a(data1, data2 =&gt; { function b(data2, data3 =&gt; { function c(data3, data4 =&gt; { function d(data4, data5 =&gt; { .... }) }) }) }) 也就是说当我们遇到有多层回调的时候，这个结构就相当难看了，当时如果用async或者Promise的话,可以将多层回调变成同步的样式来进行操作 //async async.waterfall([ cb =&gt; cb(err, data1), cb =&gt; cb(err, data1, data2), cb =&gt; cb(err, data2, data3), cb =&gt; cb(err, data3, data4), ... ], (err, r) =&gt; console.log(&quot;end&quot;)) // Promise var promise = new Promise((resolve, reject) =&gt; { resolve(data1) }) promise .then(data1 =&gt; return data2) .then(data2 =&gt; return data3) .then(data3 =&gt; return data4) ... 简单对比async的主要实现方式挺容易理解的，它本质是提供了一系列的工具函数，来帮助解决多层回调的问题，最常见的方式就是将多个异步操作集合到数组里，然后根据这些异步操作的相互间的关系来选择它提供的方法进行实现。 而Promise是将异步操作封装为对象，异步的结果输出到对象的.then()方法里，然后.then()方法的返回值又是一个Promise对象并且在.then()方法里return的值会传递到下一个.then()，即链式法则。 在async中我们如果在处理上一个异步回调的结果的时候，又需要用一个异步回调，并且还需要将这个异步回调的结果传递给下一个异步回调的话，我们只需要将结果放在callback()里就行了。 但是在Promise里，我们如果在.then()方法里还需要有异步操作，并且需要将这个异步操作的值传递出去，以便链式方法能够获取到这个参数该怎么办呢？ 这里我们在稍微改一下上一个例子，我们先向write.txt里面写入一个’test’字符串，操作成功后读取write.txt的内容并打印，然后再读取read.txt里面的内容，然后将之前内容覆盖并写入write.txt里面： var Promise = require(&apos;bluebird&apos;); var fs = require(&apos;fs&apos;); var readFileAsync = Promise.promisify(fs.readFile); var writeFileAsync = Promise.promisify(fs.writeFile); writeFileAsync(&apos;./write.txt&apos;, &apos;test\\n&apos;) .then(() =&gt; readFileAsync(&apos;./write.txt&apos;)) .then((data) =&gt; { console.log(data.toString()); return readFileAsync(&apos;./read.txt&apos;) }) .then(data =&gt; writeFileAsync(&apos;./write.txt&apos;, data)) .then(() =&gt; readFileAsync(&apos;./write.txt&apos;)) .then(data =&gt; console.log(data.toString())); 首先我们将fs.readFile和fs.writeFile通过bluebird的promisify方法做Promise封装，命名为readFileAsync和writeFileAsync。这样它们的返回值就变成了Promise对象，并且它们的本来应该返回到回调函数里的结果返回到了.then()方法里。因为我们只要在.then()方法里return Promise对象，.then()的值就是我们内层返回的Promise对象，故我们又可以继续用.then()来使用数据并且操作，依次类推。 所以用Promise的进行多层异步回调的简化的一个基本思路就是，我们需要将这些异步回调想办法返回Promise对象，做Promise封装也好，重新构建一个Promise对象返回也好，都大同小异。 而async的对多层回调简化的思路就是只需要将值传递到callback里，就能被外层的函数来获取到结果。","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://shadowwood.me/categories/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://shadowwood.me/tags/javascript/"},{"name":"异步","slug":"异步","permalink":"https://shadowwood.me/tags/异步/"},{"name":"node.js","slug":"node-js","permalink":"https://shadowwood.me/tags/node-js/"},{"name":"async","slug":"async","permalink":"https://shadowwood.me/tags/async/"},{"name":"Promise","slug":"Promise","permalink":"https://shadowwood.me/tags/Promise/"}]},{"title":"js实现图片异步上传","slug":"2016-04-22-js-upload-picture","date":"2016-04-22T05:23:00.000Z","updated":"2018-04-19T12:06:26.859Z","comments":true,"path":"2016/04/22/2016-04-22-js-upload-picture/","link":"","permalink":"https://shadowwood.me/2016/04/22/2016-04-22-js-upload-picture/","excerpt":"前言最近在学习node.js的express框架，其中包含了一个用户系统。之前在做用户系统的时候对用户信息的编辑更新都是用的同步的方式来进行表单提交，这一次兴趣使然想用异步的方式来实现信息编辑的表单提交，用jquery框架的ajax方法的对普通的文本信息都能很好的实现。但是在图片的异步请求提交的时候遇到了一些问题。因为jquery框架的ajax方法本身对二进制数据的表单提交没有很好的支持，网上的很多推荐实现方式都说用额外的插件来实现，但是由于‘’不可描述“的原因，当时下载这些插件来使用有些不方便，所以便一直探索不用其他插件的情况下，用jquery的ajax或者原生的js来实现.","text":"前言最近在学习node.js的express框架，其中包含了一个用户系统。之前在做用户系统的时候对用户信息的编辑更新都是用的同步的方式来进行表单提交，这一次兴趣使然想用异步的方式来实现信息编辑的表单提交，用jquery框架的ajax方法的对普通的文本信息都能很好的实现。但是在图片的异步请求提交的时候遇到了一些问题。因为jquery框架的ajax方法本身对二进制数据的表单提交没有很好的支持，网上的很多推荐实现方式都说用额外的插件来实现，但是由于‘’不可描述“的原因，当时下载这些插件来使用有些不方便，所以便一直探索不用其他插件的情况下，用jquery的ajax或者原生的js来实现. 使用jquery的ajax方法实现前端表单&lt;form id=&quot;avatar_form&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;avatar&quot;&gt; &lt;/form&gt; js代码function uploadAvatar () { var data = new FormData(); var files = $(&quot;input[name=&apos;avatar&apos;]&quot;)[0].files; if (files) { data.append(&quot;file&quot;, files[0]) } else { alert(&quot;please choose a picture&quot;) } $.ajax({ type: &apos;put&apos;, dataType: &apos;json&apos;, url: &quot;/user/change_avatar&quot; data: data, contentType: false, processData: false, success: function (data) { alert(&apos;success&apos;); } }) } 使用jquery的ajax方法实现的主要思想是我们重新构建一个表单，用jquery读取html中表单的图片信息，然后向新表单之中加入文件，并且不让ajax来自动处理我们的表单数据，直接将原始表单数据提交 相信大家也注意到了，在ajax的设置参数里，我们多了几个参数的设置： contentType processDate 根据jquery ajax的官方文档http://api.jquery.com/jquery.ajax/，这几个参数的设置主要是一下用途： contentType (值类型:Boolean or String, 默认值:’application/x-www-form-urlencoded; charset=UTF-8’)这个值用来设置HTTP请求的content-type头信息，默认是’application/x-www-form-urlencoded; charset=UTF-8’。在jQuery1.6版本之后，这个值可以设置为false，用来告诉jQuery不要设置请求的content-type头信息。由于我们这里需要使用原始的表单，不需要jQuery帮我们设置content-type信息，FormData对象会根据表单的值来设置，故而将这个值设置为false。 processData (值类型:Boolean, 默认值: true)这个值的设定是整个过程最重要的一部分，因为当这个值为true的时候，ajax会将data里的值处理成contentType里我们设置的类型，默认是”application/x-www-form-urlencoded”。当这个值为false的时候，ajax就不会对data里的值进行处理，这正是我们所需要的 其实整个过程最重要的部分还是FormData。FormData是XMLHttpRequest Level 2添加了一个新的接口.利用FormData对象,我们可以通过JavaScript用一些键值对来模拟一系列表单控件,构造函数 new FormData(optional HTMLFormElement form) form 参数是一个可选的HTML表单元素,可以包含任何形式的表单控件,包括文件输入框。 FormData对象还可以使用append方法添加键值对，如 var form = new FormData(); form.append(&quot;name&quot;, &quot;testName&quot;); form.append(&quot;num&quot;, 123456); // 数字123456被立即转换成字符串&quot;123456&quot; // fileInputElement中已经包含了用户所选择的文件 form.append(&quot;file&quot;, fileInputElement.files[0]); 使用FormData最主要的优势便是我们可以用它构造表单来传输二进制文件，故而是异步上传图片的较好选择。在浏览器的支持方面 Chrome FireFox(Gecko) IE Opera Safari 7+ 4.0(2.0) 10+ 12+ 5+ XMLRequest实现当然除了ajax异步的方式，也可以是用XMLRequest的方式实现异步请求，如果是要传输二进制文件的话，一样是可以用到FormData对象来构造表单，然后用XMLRequest异步请求的方式将FormData对象当作表单提交即可。 var formEle = document.getElementById(&quot;avatar_form&quot;); var form = new FormData(formEle); var xReq = new XMLHttpRequest(); xReq.open(&quot;PUT&quot;, &quot;/user/change_avatar&quot;, true); xReq.onload = function(oEvent) { if (oReq.status == 200) { alert(&quot;success&quot;); } else { alert(&quot;failed&quot;) } }; xReq.send(form);","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://shadowwood.me/categories/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://shadowwood.me/tags/javascript/"},{"name":"图片上传","slug":"图片上传","permalink":"https://shadowwood.me/tags/图片上传/"},{"name":"异步","slug":"异步","permalink":"https://shadowwood.me/tags/异步/"}]},{"title":"浅析javascript的继承方式","slug":"2016-04-20-javascript-inherit","date":"2016-04-20T09:08:30.000Z","updated":"2018-04-19T12:06:26.859Z","comments":true,"path":"2016/04/20/2016-04-20-javascript-inherit/","link":"","permalink":"https://shadowwood.me/2016/04/20/2016-04-20-javascript-inherit/","excerpt":"前言继承是面向对象语言的一个最为重要的概念。许多面向对象语言都支持两周继承方式：接口继承和实现继承。接口继承只继承方法签名，实现继承则继承实际的方法。然而，函数并没有签名，所以在ES中无法实现接口继承，只有实现继承，并且实现方式主要是依靠原型链来实现。","text":"前言继承是面向对象语言的一个最为重要的概念。许多面向对象语言都支持两周继承方式：接口继承和实现继承。接口继承只继承方法签名，实现继承则继承实际的方法。然而，函数并没有签名，所以在ES中无法实现接口继承，只有实现继承，并且实现方式主要是依靠原型链来实现。 原型链原型链的基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法，其基本模式如下： function SuperType () { this.property = true; } SuperType.prototype.getProperty = function () { console.log(this.property) } function SubType () { this.subProperty = false; } SubType.prototype = new SuperType(); SubType.prototype.getSubProperty = function () { console.log(this.subProperty) } var instance = new SubType(); console.log(instance.property); // true console.log(instance.subProperty); // false instance.getProperty(); // true instance.getSubProperty(); // false 在以上代码中，SubType继承了SuperType的属性和方法，实现的方法是通过将SuperType的实例赋于SubType.prototype，即重写SubType的原型对象。 我们可以通过instanceof操作符或者isPrototypeOf()方法来确定原型和实例之间的关系，对于以上代码： console.log(instance instanceof Object); // true console.log(instance instanceof SuperType); // true console.log(instance instanceof SubType); // true console.log(Object.prototype.isPrototypeOf(instance)); // true console.log(SuperType.prototype.isPrototypeOf(instance)); // true console.log(SubType.prototype.isPrototypeOf(instance)); //true 原型链继承是最常见的继承方式，但是也存在一些问题。最主要的问题来自包含引用类型的原型，例如: function SuperType () { this.arr = [1, 2, 3, 4] } function SubType () {} SubType.prototype = new SuperType(); var instance1 = new SubType(); instance1.arr.push(4); console.log(instance1.arr); // 1, 2, 3, 4 var instance2 = new SubType(); console.log(instance2.arr); // 1, 2, 3, 4 在这个例子中，我们想对instance1的arr数组添加元素4，但是却影响到了instance2。这是因为arr这个属性是来自于SuperType的同一个实例，也就是说instance1.arr和instance2.arr指向的是同一个数组，当对instance1.arr操作时，就会一样影响到instance2.arr。 原型链的第二个问题是：当我们创建子类型的实例时，没有办法在不影响所有超类型的对象实例的情况下向继承于超类型的构造函数中传递参数。 基于这两个主要问题，所以在实际运用中很少单独用原型链的方式来实现继承。 借用构造函数借用构造函数的基本思想是在子类型构造函数的内部调用超类型构造函数，如下所示: function SuperType (name) { this.arr = [1, 2, 3]; this.name = name; } function SubType () { // 继承 SuperType SuperType.call(this, &apos;subtype&apos;) } var instance0 = new SuperType(&apos;supertype&apos;); console.log(instance0.name); // &apos;supertype&apos; var instance1 = new SubType(); instance1.arr.push(4); console.log(instance1.arr); // 1, 2, 3, 4 console.log(instance1.name); // &apos;subtype&apos; console.log(instance0.name); // &apos;supertype&apos; var instance2 = new SubType(); console.log(instance2.arr); // 1, 2, 3 console.log(instance2.name); // &apos;subtype&apos; 上例中，通过在SubType中使用SuperType.apply()方法来操作SubType的作用域this，使得子类型定义了与超类型相同的属性，从而实现了SubType继承了SuperType的属性，并且我们还能在不影响SuperType所有对象实例的情况下，通过传递参数来定义继承于SuperType的属性。 借用构造函数的继承方式解决了原型链中存在的两个主要问题，即： 包含引用类型引起的问题 无法在不影响超类型的所有实例对象的情况下向子类型构造中向超类型构造函数传递参数 但是借用构造函数由于是用在内部调用构造函数来实现继承的，所以它的方法都是在构造函数里定义，那么就无法像原型链一样使用Object.prototype.attr = function 的定义方法的方式来实现函数的复用，所以在实际运用中也很少单独使用借用构造函数的方式来实现继承 组合继承结合原型链和借用构造函数的继承方式，取长补短便产生了组合继承，即使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承，如下所示: function SuperType (name) { this.name = name; this.arr = [1, 2, 3]; } function getName () { console.log(this.name) } SuperType.prototype.getName = getName; function SubType (name, age) { // 借用构造函数，实现继承实例属性 SuperType.call(this, name); this.age = age; } // 原型继承，实现对方法的继承 SubType.prototype = new SuperType(); SubType.prototype.constructor = SubType; SubType.prototype.getAge = function () { console.log(this.age) }; var instance1 = new SubType(&apos;in1&apos;, 10); instance1.arr.push(4); console.log(instance1.arr); // 1, 2, 3, 4 instance1.getName(); // &apos;in1&apos; instance1.getAge(); // 10 var instance2 = new SubType(&apos;in2&apos;, 20); console.log(instance2.arr); // 1, 2, 3 instance2.getName(); // &apos;in2&apos; instance2.getAge(); //20 在本例中，SubType既使用了原型链的继承方式继承了SuperType的getName方法，并且可以用函数复用的方式来定义getName方法又通过借用构造函数的继承方式继承name和arr属性，让SubType的两个不同实例分别拥有自己的属性。 组合继承避免了原型链和借用构造函数的缺陷，因而在实际应用中是JS中最常见的继承模式。 原型式继承2006年，Douglas Crockford提出原型式继承的方式，即借助原型可以基于已有的对象创造新对象，同时还不必自己因此创建自定义类型，他给出了如下代码: function object (o) { function F () { } F.prototype = o; return new F() } 在object()函数内部定义了一个临时的构造函数F，将传入的实例对象o作为F的原型，然后返回F的一个新实例。 在ES5中，这个方法被规范化，并且用Object.create()来实现，即我们可以通过Object.create()来实现与构造函数实现原型链一样的效果： var whiteCar = { color: &apos;white&apos;, users: [&apos;Tom&apos;, &apos;Jim&apos;] } var blackCar = Object.create(whiteCar) blackCar.color = &apos;black&apos; blackCar.users.push(&apos;Black&apos;) console.log(whiteCar.users) // &apos;Tom&apos;, &apos;Jim&apos;, &apos;Black&apos; 如上例所示原型式继承和原型链一样存在因包含引用类型引起的问题，因为它的实现方式本质和之前提到的原型链一样，只不过它没有采用构造函数来实现，而是直接操作对象来实现继承。 寄生式继承寄生式继承是基于原型式继承思想的一种实现方法，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真的是它做了所有的工作一样返回对象，如下所示： function createCar (original) { var clone = Object.create(original); clone.getColor = function () { console.log(this.color) } return clone; } var whiteCar = { color: &apos;white&apos;, users: [&apos;Tim&apos;, &apos;Tom&apos;] } var blackCar = createAnother(whiteCar); blackCar.color = &apos;black&apos;; blackCar.getColor() // &apos;black&apos; 寄生式继承相对于原型式继承只是将增强新对象（添加属性和方法）在一个函数中实现，其中，不一定要使用Object.create()来创造新对象，任何可以返回新对象的方法都可以。 寄生组合式继承用寄生式继承将组合式继承改进，即使用寄生式继承来继承超类型的原型，然后再将结果指定的子类型的原型，就形成了寄生组合式继承的方法如下所示： // 寄生式组合式继承核心 function inheritPrototype (subType, superType) { var prototype = Object.create(superType.prototype); // 为创建的副本重写constructor属性，弥补因重写原型而失去默认的construct属性 prototype.constructor = subType; SubType.prototype = prototype; } function SuperType (name) { this.name = name; this.arr = [1, 2, 3] } SuperType.prototype.getName = function () { console.log(this.name) } function SubType (name, age) { SuperType.call(this, name) this.age = age } inheritPrototype(SubType, SuperType); SubType.prototype.getAge = function () { console.log(this.age); } 其中inheritPrototype函数是整个寄生组合式继承过程的核心，即通过类似寄生式继承的方式实现Subtype对SuperType的原型继承，然后在子类型实例化的时候，又因为内部构造函数实现借用构造函数方式来继承了SuperType的属性。 这个例子的高效率体现在它只调用了一次 SuperType构造函数，而在组合式继承的例子里面调用了两次(SuperType.call(), new SuperType)，并且因此避免了在SubType.prototype上面创建不必要的，多余的属性。与此同时还保证了原型链的不变，从而能正常使用 instanceof 和 isPrototypeOf方法。 故寄生组合式继承是目前最理想的继承方法。 参考资料： 《JavaScript 高级程序设计(第三版)》(Nicholas C.Zakas著，李松峰 曹力译)","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://shadowwood.me/categories/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://shadowwood.me/tags/javascript/"},{"name":"继承","slug":"继承","permalink":"https://shadowwood.me/tags/继承/"}]},{"title":"node.js的安装与npm的使用","slug":"2016-04-19-npm-setup-and-use","date":"2016-04-19T07:35:30.000Z","updated":"2018-04-19T12:06:26.859Z","comments":true,"path":"2016/04/19/2016-04-19-npm-setup-and-use/","link":"","permalink":"https://shadowwood.me/2016/04/19/2016-04-19-npm-setup-and-use/","excerpt":"什么是npmnpm, Node Package Manager, 是随同node.js一起安装的包管理工具。该管理工具可用于从第三方网站上下载node.js包，常用于： 允许开发者从npm服务器下载别人编写的第三方包到本地使用。 允许开发者从npm服务器下载并安装别人编写的命令行程序到本地使用。 允许开发者将自己编写的包或命令行程序上传到npm服务器供别人使用。 从而方便开发者的项目构建和解决node.js项目部署上的很多问题。","text":"什么是npmnpm, Node Package Manager, 是随同node.js一起安装的包管理工具。该管理工具可用于从第三方网站上下载node.js包，常用于： 允许开发者从npm服务器下载别人编写的第三方包到本地使用。 允许开发者从npm服务器下载并安装别人编写的命令行程序到本地使用。 允许开发者将自己编写的包或命令行程序上传到npm服务器供别人使用。 从而方便开发者的项目构建和解决node.js项目部署上的很多问题。 node.js的安装node.js历史包版本下载地址 https://nodejs.org/dist/ windows 下载安装包安装: 在历史包版本里面找到最新版本的.msi文件，下载并执行安装；在cmd里面输入path查看是否有npm的环境变量()，如果没有则需要将手动配置node.js和npm的环境变量，即将其安装路径添加到环境变量path之中就行（一般来说安装包里有选项会默认帮用户配置的） 下载二进制文件安装: 在历史包版本里找到最新版本的.exe文件，下载并运行即可; linux ubuntu 从github上获取源码安装: 在 Github 上获取 Node.js 源码： $ sudo git clone https://github.com/nodejs/node.git 修改目录权限： $ sudo chmod 755 -R node 使用 ./configure 创建编译文件，并按照： $ cd node $ sudo ./configure $ sudo make $ sudo make install 查看 node 版本： $ node --version 使用apt-get进行安装： 直接运行以下命令即可： sudo apt-get install nodejs sudo apt-get install npm Mac Os使用homebrew进行安装: brew install node npm常见命令与使用安装node.js的包 npm install &lt;name&gt; 安装nodejs的依赖包 npm install &lt;name&gt; -g 将包安装到全局环境中但是代码中，直接通过require()的方式是没有办法调用全局安装的包的。全局的安装是供命令行使用的 npm install &lt;name&gt; –save 安装的同时，将信息写入package.json中项目路径中如果有package.json文件时，直接使用npm install方法就可以根据dependencies配置安装所有的依赖包 npm init 引导你创建一个package.json文件，包括名称、版本、作者这些信息等 npm remove &lt;name&gt; 移除包 npm update &lt;name&gt; 更新包 npm ls 列出当前安装的了所有包 npm root 查看当前包的安装路径9 npm root -g 查看全局的包的安装路径 npm help 帮助，如果要单独查看install命令的帮助，可以使用的npm help install npm config set registry &lt;源地址&gt; npm换源命令，&lt;源地址&gt;的格式须以’http://‘或’https://‘开头 npm view &lt;name&gt; versions 查看npm包的历史版本","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://shadowwood.me/categories/Nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://shadowwood.me/tags/nodejs/"},{"name":"npm","slug":"npm","permalink":"https://shadowwood.me/tags/npm/"}]},{"title":"PPPoE服务器添加Radius支持","slug":"2015-05-19-build-PPPoE-and-Radious-On-Ubuntu","date":"2015-05-19T00:46:00.000Z","updated":"2018-04-19T12:06:26.859Z","comments":true,"path":"2015/05/19/2015-05-19-build-PPPoE-and-Radious-On-Ubuntu/","link":"","permalink":"https://shadowwood.me/2015/05/19/2015-05-19-build-PPPoE-and-Radious-On-Ubuntu/","excerpt":"前言本片文章紧接之前的PPPoE服务器配置和Radius服务器配置，如果还没进行过这两步的同志请移步这里： ubuntu上搭建PPPoE认证服务器 ubuntu上安装和配置FreeRadius","text":"前言本片文章紧接之前的PPPoE服务器配置和Radius服务器配置，如果还没进行过这两步的同志请移步这里： ubuntu上搭建PPPoE认证服务器 ubuntu上安装和配置FreeRadius PPPoE服务器配置我们只需要在之前的PPPoE服务器上修改和添加一些东西即可。 首先，确认 /etc/ppp/ 路径下是否有radius文件夹，若没有，则安装radiusclient1，即： sudo apt-get install radiusclient1 然后在 /etc/ppp/路径下新建一个radius文件夹，将/etc/radiusclient/ 文件夹下的所有文件拷贝到 /etc/ppp/radius/ 目录下(若已有radius文件夹，请忽略此步骤) 之后，修改 /etc/ppp/radius/radiusclient.conf 文件，修改以下两项： authserver 10.37.129.5:1812 acctserver 10.37.129.5:1813 其中 10.37.129.5 为笔者配置的Freeradius服务器ip地址，读者需根据自己的Freeradius服务器地址来配置该项。 修改 /etc/ppp/pppoe-server-options 文件： auth require-chap default-mru default-asyncmap lcp-echo-interval 60 lcp-echo-failure 5 ms-dns 192.168.0.1 ms-dns 10.132.129.1 noipdefault noipx nodefaultroute noproxyarp noktune netmask 255.255.255.0 logfile /var/log/pppd.log plugin radius.so #配合radius 使用 plugin radattr.so radius-config-file /etc/ppp/radius/radiusclient.conf 注意 ms-dns为 DNS 服务器ip地址，请读者根据自己实际情况配置； radius.so 和 radattr.so为radius支持文件，请读者仔细检查 /etc/ppp/ 路径下是否有这两个文件，若没有就去百度或者谷歌下载吧＝。＝； 接着修改/etc/ppp/radius/server 文件，添加freeradius服务器ip地址和共享密钥(需和freeradius服务器配置一致)： 10.37.129.5 testing123 其中 10.37.129.5 为笔者的Freeradius服务器地址，请读者根据自己的实际情况配置；testing123为readius客户端与freeradius服务器的共享密钥，需要与之后的freeradius服务器配置一致。 Freeradius服务器配置接着之前Freeradius服务器的配置。 修改 /etc/freeradius/client.conf 文件，添加PPPoE服务器的信息： client 10.37.129.4 { ipaddr = 10.37.129.4 secret = testing123 require_message_authenticator = no } 其中10.37.129.4为PPPoE服务器的ip地址，请读者根据自己的实际情况配置。 启动服务器启动freeradius服务器 freeradius -X 启动PPPoE服务器 sudo pppoe-server -I eth1 -L 11.11.11.1 -R 11.11.11.10 -N 20 参考博客 http://blog.chinaunix.net/uid-21651676-id-3030200.html http://blog.atime.me/note/freeradius_daloradius_install_config_on_ubuntu.html","categories":[{"name":"Linux","slug":"Linux","permalink":"https://shadowwood.me/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://shadowwood.me/tags/Linux/"},{"name":"PPPoE","slug":"PPPoE","permalink":"https://shadowwood.me/tags/PPPoE/"},{"name":"Radius","slug":"Radius","permalink":"https://shadowwood.me/tags/Radius/"}]},{"title":"ubuntu上安装和配置FreeRadius","slug":"2015-04-29-build-FreeRadius-On-Ubuntu","date":"2015-04-29T07:09:00.000Z","updated":"2018-04-19T12:06:26.859Z","comments":true,"path":"2015/04/29/2015-04-29-build-FreeRadius-On-Ubuntu/","link":"","permalink":"https://shadowwood.me/2015/04/29/2015-04-29-build-FreeRadius-On-Ubuntu/","excerpt":"前言前面笔者分享了在ubuntu上搭建PPPoE服务器的步骤和一些问题及解决办法，但是这学期的综合课程设计内容是要求搭建和配置由radius协议实现认证和计费的PPPoE服务器，之前的东西只是第一步，本文接着分享如何在ubuntu上安装配置FreeRadius来实现基于radius协议的认证和计费。关于radius的介绍可以看一下这里： http://blog.csdn.net/liang13664759/article/details/1574367/","text":"前言前面笔者分享了在ubuntu上搭建PPPoE服务器的步骤和一些问题及解决办法，但是这学期的综合课程设计内容是要求搭建和配置由radius协议实现认证和计费的PPPoE服务器，之前的东西只是第一步，本文接着分享如何在ubuntu上安装配置FreeRadius来实现基于radius协议的认证和计费。关于radius的介绍可以看一下这里： http://blog.csdn.net/liang13664759/article/details/1574367/ 系统配置及需要安装的软件 系统：ubuntu 14.04 安装软件： freeradius-mysql(自动安装freeradius本体) mysql-server 安装命令： sudo apt-get install freeradius-mysql mysql-server 进行FreeRadius基本配置修改 /etc/freeradius/clients.conf，这是FreeRadius的客户端配置文件，在这里我们要将我们之后要与服务器连接的客户端的信息写入配置文件，例如加入如下几行： client 192.168.0.2 { ipaddr = 192.168.0.2 secret = testing123 require_message_authenticator = 0 } 表示有一个 ip地址为192.168.0.2的客户端之后要接入Freeradius服务器，它与服务器的共享密钥为 testing123。该配置文件一般已经配置好了一个本地测试的客户端，即ip地址为 localhost 的客户端。 修改 /etc/freeradius/radiusd.conf，这是FreeRadius的配置文件，取消下一行的注释来包含FreeRadius的 sql 配置文件： $INCLUDE sql.conf 修改/etc/freeradius/sql.conf，这是FreeRadius与 mysql 数据库相关的配置文件，注意一下几行： server = &quot;localhost&quot; login = &quot;root&quot; password = &quot;123456&quot; 这里为mysql数据库的ip地址，用户名和密码，默认使用3306端口，当然也可以自己加一行 port=”端口号” 来根据自己的喜好配置。(这几行应该配置文件里有，不需要修改，如果没有就自己加上) 接着取消掉文件中下面一行，来让FreeRadius从数据库里面读取客户端的信息： readclients = yes 接着切换到 /etc/freeradius/sql/mysql，该文件下的众多sql脚本文件用于构建FreeRadius的数据库，首先在admin.sql里修改数据库名称，用户名和密码等内容(默认配置是radius, root, 123456，若之前数据不是默认配置，需对sql语句进行相关修改)，这些内容必须和/etc/freeradius/sql.conf的设置相同。 最后修改/etc/freeradius/sql/mysql/dialup.conf文件，取消掉以下几行的注释来提供在线人数统计功能： simul_verify_query = &quot;SELECT radacctid, acctsessionid, username, \\ nasipaddress, nasportid, framedipaddress, \\ callingstationid, framedprotocol \\ FROM ${acct_table1} \\ WHERE username = &apos;%{SQL-User-Name}&apos; \\ AND acctstoptime IS NULL&quot; 配置mysql数据库先切换到/etc/freeradius/sql/mysql文件夹下(以便进行之后的操作)，然后登录mysql数据库： cd /etc/freeradius/sql/mysql mysql -u root -p 先创建数据库radius，然后导入文件下的sql文件： create database radius; source admin.sql; source cui.sql; source ippool.sql; source schema.sql; source wimas.sql; 再在mysql运行下面几句sql语句加入用户组： insert into radgroupreply (groupname,attribute,op,values) values (&apos;user&apos;，&apos;Auth-Type&apos;,&apos;:=&apos;,&apos;Local&apos;); insert into radgroupreply (groupname,attribute,op,values) values (&apos;user&apos;，&apos;Service-Type&apos;,&apos;:=&apos;,&apos;Framed-User&apos;); insert into radgroupreply (groupname,attribute,op,values) values (&apos;user&apos;，&apos;Framed-IP-Address&apos;,&apos;:=&apos;,&apos;255.255.255.254&apos;); insert into radgroupreply (groupname,attribute,op,values) values (&apos;user&apos;，&apos;Framed-IP-Netmask&apos;,&apos;:=&apos;,&apos;255.255.255.0&apos;); 然后加入用户账号和密码（以账号test，密码123456为例）： insert into radcheck (username,attribute,op,value) values (&apos;test&apos;,&apos;User-Password&apos;,&apos;:=&apos;,&apos;123456&apos;) 将账号加入用户组： insert into usergroup (username,groupname) values (&apos;test&apos;,&apos;user&apos;); 修改/etc/freeradius/sites-enabled/default： 找到authorize {}模块，注释掉files，去掉sql前的#号 找到accounting {}模块，注释掉radutmp,注释掉去掉sql前面的#号。 找到session {}模块，注释掉radutmp，去掉sql前面的#号。 找到post-auth {}模块，去掉sql前的#号，去掉sql前的#号（Post-Auth-Type REJECT内） 修改/etc/freeradius/sites-enabled/inner-tunnel： 找到authorize {}模块，注释掉files，去掉sql前的#号。 找到session {}模块，注释掉radutmp，去掉sql前面的#号。 找到post-auth {}模块，去掉sql前的#号，去掉sql前的#号（Post-Auth-Type REJECT内）。 到这里就基本配置完毕了。 本地测试使用调试模式启动 FreeRadius： freeradius -X 使用radtest模拟向服务器发送请求： radtest test 123456 localhost 1812 testing123 注意 test为用户账号，123456为密码，这两个必须和我们之前在mysql数据里面写入的用户账号和密码对应，否则服务器会返回Access-reject响应，localhost和1812为FreeRadius服务器的 ip地址和端口，testing123是我们之前在/etc/freeradius/clients.conf里面配置的与本地客户端的共享密钥。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://shadowwood.me/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://shadowwood.me/tags/Linux/"},{"name":"FreeRadius","slug":"FreeRadius","permalink":"https://shadowwood.me/tags/FreeRadius/"}]},{"title":"javascript实现按钮计时","slug":"2015-04-18-Js-button-timer","date":"2015-04-18T10:15:30.000Z","updated":"2018-04-19T12:06:26.859Z","comments":true,"path":"2015/04/18/2015-04-18-Js-button-timer/","link":"","permalink":"https://shadowwood.me/2015/04/18/2015-04-18-Js-button-timer/","excerpt":"最近实验和项目忙得不可开交，终于可以闲下心来写写博客了。 这段时间都在做后台管理的web端，自然也离不开短信验证那一套东西，最开始对js不熟，做按钮计时花了大半时间。今天就拿这个下手吧。为了方便操作html中的元素，就直接用jquery框架了。","text":"最近实验和项目忙得不可开交，终于可以闲下心来写写博客了。 这段时间都在做后台管理的web端，自然也离不开短信验证那一套东西，最开始对js不熟，做按钮计时花了大半时间。今天就拿这个下手吧。为了方便操作html中的元素，就直接用jquery框架了。 首先先确定需要输入的东西，一个是手机号，一个是验证码。 &lt;script src=&quot;http://cdn.bootcss.com/jquery/1.11.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;label&gt;手机号：&lt;/label&gt; &lt;input id=&quot;phone&quot;&gt; &lt;br/&gt; &lt;label&gt;验证码：&lt;/label&gt; &lt;input&gt; &lt;button id=&quot;get_verify_code&quot;&gt;获取验证码&lt;/button&gt; 首先我们得实现在用户点击意义“获取验证码”按钮后，得有一个计时机制，防止用户在短时间内多次获取验证码，而且同时也有暗示用户获取验证码这步操作已经执行。计时的功能用setInterval()函数来实现。先贴出代码： &lt;script type=&quot;text/javascript&quot;&gt; var count; var countdown; var button = $(&apos;#get_verify_code&apos;) function Count(){ count--; button.text(&quot;请等待&quot;+count+&quot;秒&quot;); if(count == 0){ clearInterval(countdown); button.text(&quot;获取验证码&quot;); button.removeAttr(&apos;disabled&apos;); } } button.click(function(){ count = 30; $(this).text(&quot;请等待&quot;+count+&quot;秒&quot;); $(this).attr(&apos;disabled&apos;, true); countdown = setInterval(Count, 1000); }) &lt;/script&gt; OK，这段代码的两个重点就是setIntercval()函数和全局变量的使用。首先我们来了解下setInterval()函数。 函数定义： setInterval() 方法可按照指定的周期（以毫秒计）来调用函数或计算表达式。 setInterval() 方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。由 setInterval() 返回的 ID 值可用作 clearInterval() 方法的参数。 函数语法： setInterval(code,millisec[,”lang”]) 参数： code必须。要调用的函数或要执行的代码串。 millisec必须。周期性执行或调用 code 之间的时间间隔，以毫秒计。 返回值: 一个可以传递给 Window.clearInterval( ) 从而取消对 code 的周期性执行的值。 我们将计时函数 Count( ) 用 setInterval( ) 函数来不断执行，知道计时标志 count &lt;= 0 时，停止计时，将按钮恢复如初。在代码中我用了setInterval(Count, 1000), 其中 Count 时 Count( )函数的函数名，“1000”是指定的周期，即1000毫秒＝1秒。 至于为什么我要将 count 和 countdown 定义为全局变量，以下便是我的理由： count 作为计时标志，每次都会被函数 Count( ) 调用操作，故应将其定义为全局变量避免出现错误。 countdown 是 setInterval( ) 返回的 id 值，用来作为 clearInterval( ) 的参数停止计时，而在这里clearInterval( ) 被用在 Count( ) 之中，而 Count( ) 又是在 setInterval( ) 里被调用，为了使countdown有效，其必须定义在 setInterval( ) 之外，故将其定义为全局变量。 这样一看其实还挺明显的，但是之后等我们加入下一个功能，你就会明白全局变量的重要性了。 相信大家已经发现这个按钮计时有个明显的缺陷了，那就是只要你将当前的页面一刷新，按钮又可以使用了，那么做的这一切就没用了。 要解决这个问题有两种方案： 在后台存储用户点击按钮时的时间，每次用户向后台发出页面请求的时候，判定当前的时间距离上一次点击按钮的时间相差是否有30秒，然后进行对应的操作； 在本地存储用户点击按钮时的时间，用法同上。 这里我们为了减少向服务器请求的数据（我不会告诉你其实是我想偷懒！＝。＝），便采用第二种方案。 本地存储的方式有两种，一是使用 localStorage, 二是使用 sessionStorage。前者是永久存储，后者如果关闭浏览器就清空。这里我们用 localStorage。 ok，想法就这样，先贴出代码： &lt;script type=&quot;text/javascript&quot;&gt; $(document).ready(function(){ var count; var countdown; var button = $(&apos;#get_verify_code&apos;); function Count(){ count--; button.text(&quot;请等待&quot;+count+&quot;秒&quot;); if(count == 0){ clearInterval(countdown); button.text(&quot;获取验证码&quot;); button.removeAttr(&apos;disabled&apos;); localStorage.removeItem(&apos;verify_time&apos;) } } if(localStorage[&apos;verify_time&apos;]){ var last_time = parseInt(localStorage[&apos;verify_time&apos;]); var now_time = parseInt(new Date().getTime()); if(now_time-last_time &lt; 30000){ count = parseInt(30-(now_time - last_time)/1000); button.text(&quot;请等待&quot;+count+&quot;秒&quot;); button.attr(&apos;disabled&apos;, true); countdown = setInterval(Count, 1000); } else{ localStorage.removeItem(&apos;verify_time&apos;); } } button.click(function(){ count = 30; $(this).text(&quot;请等待&quot;+count+&quot;秒&quot;); $(this).attr(&apos;disabled&apos;, true); localStorage[&apos;verify_time&apos;] = new Date().getTime(); countdown = setInterval(Count, 1000); }) }); &lt;/script&gt; 首先用 $(ducument).ready(function( ){ }) 来实现页面的初始化操作，保证需要的代码操作执行完后，才能对页面进行下一步操作。 这里我们将点击“获取验证码按钮”的时间用时间戳存在localStorage[‘verify_time’] 里，每次计时结束 或者 下一次刷新页面的时候已经距离上次操作30秒后，就将其删除。 每次刷新页面的时候，先判定本地是否记录有上次获取验证码操作的时间，若有，则计算距离上次操作时间是否超过30秒，如果低于30秒，则继续计时；否则，删除本地的记录。 由于 localStorage 都是存的字符串类型，所以在计算时间差和对 count 进行赋值的时候，都要将其转换为int类型。 在这里，我们就能发现重视全局变量带来的好处了，count 和 countdown 虽然都会被函数以及函数的内层调用，但是这些函数都不是在同时对这两个变量进行操作，所以理论上不会引起冲突，故而将 count 和 countdown 定义为全局变量，不仅使得逻辑清楚，还使得代码简洁，减少了很多不必要的操作。 在这之前，我犯过许多错，其中就包括对全局变量的使用不当，也是由于python用惯了，没重视这方面问题，老是喜欢使用局部变量，使得代码逻辑混乱，半天找不出问题。 最后爽性全删掉，重新整理思路，删繁就简，最后才发现，其实完全可以用全局变量，不仅清晰易懂，还减少了很多不必要的操作。","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://shadowwood.me/categories/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://shadowwood.me/tags/javascript/"}]},{"title":"ubuntu上搭建PPPoE认证服务器","slug":"2015-04-18-build-PPPoE-On-Ubuntu","date":"2015-04-18T05:13:37.000Z","updated":"2018-04-19T12:06:26.859Z","comments":true,"path":"2015/04/18/2015-04-18-build-PPPoE-On-Ubuntu/","link":"","permalink":"https://shadowwood.me/2015/04/18/2015-04-18-build-PPPoE-On-Ubuntu/","excerpt":"前言 对于PPPoE很多人应该不陌生，拨号上网都碰过这玩意儿，但是在后台到底是怎么实现这个认证的，了解的人应该不多。正好这学期综合课程设计老师要求搞这玩意儿，那就搞搞咯，时间上的话大概一天就搞定了，但是之后去理解这些配置做了什么东西还是花了很久时间。","text":"前言 对于PPPoE很多人应该不陌生，拨号上网都碰过这玩意儿，但是在后台到底是怎么实现这个认证的，了解的人应该不多。正好这学期综合课程设计老师要求搞这玩意儿，那就搞搞咯，时间上的话大概一天就搞定了，但是之后去理解这些配置做了什么东西还是花了很久时间。 配置 系统：ubuntu14.04 PPPoE软件：ppp 虚拟机网络模式：PPPoE服务器(双网卡：host-only模式 + 桥接模式), radius服务器(host-only模式) 搭建PPPoE服务器首先直接通过apt-get安装ppp软件： sudo apt-get install ppp 然后修改ppp的配置文件options，该文件在/etc/ppp文件夹下 cd /etc/ppp sudo gedit options 在这里我们需要修改几个地方： 设置ms-dns： 这个参数是设置给客户端的dns服务器地址，和 PPPoE 服务器的dns服务器地址对应，可用查看自己服务器网络的dns地址并复制上去； 注释掉+pap，取消掉-pap的注释，表示 PPPoE 服务器不使用pap认证方式； 取消掉+chap的注释，表示PPPoE服务器使用chap认证方式； 然后我们设置 chap-secrets 文件，直接在最后一行按 用户名服务器名密码ip地址 的格式插入，例如： test * 123456 * 表示用户名为test ，服务器为任意，密码为123456，ip地址任意 接下来配置 pppoe-server-options 文件，如果/etc/ppp目录下没有这个文件就新建一个，在文件中其他的删除或者注释掉，写入以下内容： auth require-chap logfile /var/log/pppd.log 到这里，PPPoE的服务器的基本配置算完成了，但是为了让客户端连上外网，我们还需要进一步的配置。 开启ip转发功能，在超级用户的身份下(即先使用 sudo su 切换到超级用户)，再执行以下命令： cat 1 &gt; /proc/sys/net/ipv4/ip_forward 这个命令只能暂时将ip转发功能打开，重启之后便会自动关闭，若需要一直打开ip转发功能，需要编辑 /etc/sysct1.conf , 将 net.ipv4.ip_forward=1 的注释取消掉，然后再执行 sudo sysct1 -p便可永久开启ip转发功能。 配置iptables，使用超级用户执行以下命令： iptables -A POSTROUTING -t nat -s 11.11.11.0/24 -j MASQUERADE 11.11.11.0/24 是我们之后给客户端分配的ip地址池，可以根据自己的喜好替换，只需要与之后开启pppoe-server的 地址相对应即可。 关于iptables，是一个内核防火墙模块，可以实现数据包的过滤和转发，具体请参见iptables的man手册。 最后开启 PPPoE 服务器： sudo pppoe-server -I eth1 -L 11.11.11.1 -R 11.11.11.10 -N 20 注意 -I 后的参数用于指定监听哪个网络端口。可以使用ifconfig命令查看当前工作的端口名称。笔者的虚拟机的host-only的网卡为eth1，所以使用这个网卡。 -L 后的参数用于指定在一个PPP连接中PPPoE服务器的IP地址，之前我们在配置网关的时候确定的ip地址池为 11.11.11.0/24，所以这里我们要与之对应，变使用11.11.11.1作为PPPoE服务器地址。 -R 后的参数用于指定当有客户连接到服务器上时，从哪个IP地址开始分配给客户。 -N 后的参数用于指定至多可以有多少个客户同时连接到PPPoE服务器上。 至此，PPPoE服务器搭建完毕，可以直接在另一个虚拟机的windows客户端上进行拨号连接，账号名为test，密码为123456，如果PPPoE服务器的桥接网卡能用来上网的话，那么windows客户端也能上网。 可能的问题 如果windows客户端连接的时候无法检测到PPPoE服务器的存在，即无法通过wan口发现PPPoE服务器，检查一下自己的PPPoE服务器是否启动成功。 如果windows客户端连接上了PPPoE服务器但是无法连上外网，先检查自己的PPPoE服务器是否能连上外网，若没有问题，再检查自己PPPoE的ip转发配置、options中的ms-dns是否配置正确 或者 iptables中的配置是否和pppoe-server分配给客户端的ip地址池一致 参考博客 http://blog.chinaunix.net/uid-9525959-id-4008338.htm","categories":[{"name":"Linux","slug":"Linux","permalink":"https://shadowwood.me/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://shadowwood.me/tags/Linux/"},{"name":"PPPoE","slug":"PPPoE","permalink":"https://shadowwood.me/tags/PPPoE/"}]},{"title":"python网络爬虫入门","slug":"2015-02-10-python-spider-simple","date":"2015-02-10T00:13:30.000Z","updated":"2018-04-19T12:06:25.446Z","comments":true,"path":"2015/02/10/2015-02-10-python-spider-simple/","link":"","permalink":"https://shadowwood.me/2015/02/10/2015-02-10-python-spider-simple/","excerpt":"前言对于刚刚接触python的人并且没有什么编程基础的人来说，从网络爬虫开始入门是个不错的选择。学习一门编程语言要从实践中去学习，必须要自己动手操作，光是看一系列的编程书籍，不动动手做几个实际的程序运行运行，是完全不可能掌握一门语言的。就好比武侠小说里学习一门武功一样，光是看别人操练，自己不比划比划，难道就能练就一身好功夫么？这样的话以后出身江湖不被别人砍死都是万幸了。 网络爬虫是我学习python(甚至可以说学习编程)的第一个程序(“Hello World”什么的就算了把)。所以在此极力推荐初学python的人选择从网络爬虫作为入门学习的选择。","text":"前言对于刚刚接触python的人并且没有什么编程基础的人来说，从网络爬虫开始入门是个不错的选择。学习一门编程语言要从实践中去学习，必须要自己动手操作，光是看一系列的编程书籍，不动动手做几个实际的程序运行运行，是完全不可能掌握一门语言的。就好比武侠小说里学习一门武功一样，光是看别人操练，自己不比划比划，难道就能练就一身好功夫么？这样的话以后出身江湖不被别人砍死都是万幸了。 网络爬虫是我学习python(甚至可以说学习编程)的第一个程序(“Hello World”什么的就算了把)。所以在此极力推荐初学python的人选择从网络爬虫作为入门学习的选择。 网络爬虫简介简单来说网络爬虫就是按照一定的算法和规则，自动的抓取网络信息的程序或者脚本。比较常用的也是这里要给大家介绍的基于HTTP协议的抓取网页并从中提取特定信息的脚本。 我们平常用浏览器打开一个网页，都是想网页的服务器端发送一个请求，然后服务器端做一系列的判断和处理，返回给我们一个HTML文件，然后我们的浏览器再将HTML文件解析成可视化的视图供我们浏览和操作。而这里要给大家介绍的爬虫就是将获取到HTML文件中的字符进行匹配和分析，提取我们需要的数据。 获取网页对于python的介绍和安装，百度或谷歌一搜一大片，这里我也不再做介绍，我们直接切入正题。 python作为一门脚本语言，自身集合了很多WEB操作的库，再结合其简洁的语法，往往只需要简单几行代码，就能完成一些复杂的请求和分析。 现在我们以抓取天涯论坛的帖子为例。 http://bbs.tianya.cn/post-culture-308737-1.shtml 这是一篇天涯论坛上的小说，现在我们准备写一个简单的网络爬虫，把这个网页的帖子抓取下来。 import urllib url = &quot;http://bbs.tianya.cn/post-culture-308737-1.shtml&quot; re_f = urllib.urlopen(url) page = re_f.read() print page urllib为python系统库专门用来处理WEB请求的一个包，用这个包可以实现向服务器端发送HTTP请求。 代码运行的结果是一整串的HTML代码，也就是我们做访问网页的源代码,就这样我们像浏览器一样获取网页的请求就完成了。 匹配字符串获取数据接下来我们要对获取到的网页信息做处理，只抓取我们需要的数据。这里以抓取文章标题为例。 import urllib import re url = &quot;http://bbs.tianya.cn/post-culture-308737-1.shtml&quot; re_f = urllib.urlopen(url) page = re_f.read() content = re.findall(&quot;&lt;title&gt;(.*?)_.*?&lt;/title&gt;&quot;, page) print content[0] 这里使用了正则表达式，关于正则表达式我之后会写一篇文章详细介绍。 re为python系统库用来处理正则表达式匹配的一个包。通过对网页源码的分析，我们不难发现，我们所需要的文章标题在标签之中，但是这个标签的具体内容是这样的： &lt;title&gt;男人密码:《妻子，请原谅我》(已出版)_舞文弄墨_天涯论坛&lt;/title&gt; 我们所需要的内容只有“男人密码:《妻子，请原谅我》(已出版)”，title标签和“舞文弄墨天涯论坛”我们都不需要，所以我们将 ““与”舞文弄墨天涯论坛”之间的内容用”()”提取出来即可，其中.*?表示匹配任意字符串。 re.findall()返回的是一个列表，我们只需要将第一个元素提取出来即可。 到这里，仅仅只用几行代码，一个简单的小爬虫就完成了。 上一部分主要讲解了如何使用python发送HTTP GET 请求并简单处理获取到的数据，其中用到了 urllib 和 re 库。http协议常用的请求中除了 GET 方法，还有 POST 方法。POST 方法与 GET 方法的区别网上已经有很多讲解了，这里笔者也不再赘述，简单的来说 GET 方法用于信息获取，POST 方法可能会对服务器上的资源进行修改。本篇文章以发送手机短信为例，讲解如何发送http POST请求。 准备工作这里笔者选用的短信服务商为云片网，关于云片网的api文档请移步这里： http://www.yunpian.com/api/sms.html 在api文档里已经有调用短信接口的python代码示例，不过示例代码中使用的是urllib库。因此笔者在这里使用urllib2进行编写，这个库也是python的标准库之一，用来处理http请求非常方便。 代码实现# -*- coding: utf-8 -*- import urllib2 import urllib url = &quot;http://yunpian.com/v1/sms/send.json&quot; data = urllib.urlencode({&apos;apikey&apos;: &quot;***********************&quot;, &apos;mobile&apos;: &apos;****************&apos;, &apos;text&apos;: &quot;【云片网】您的验证码是1234&quot;}) response = urllib2.urlopen(url, data) print response.read() 代码讲解apikey 对应云片网账号的 apikey，mobile 为需要发送短信的手机号码。 urllib.urlencode() 是将字典或包含两个元素的列表或元组转换为url参数，读者可以print一下本例的 data，结果输出为: “mobile=15682513909&amp;text=%E3%80%90%E4%BA%91%E7%89%87%E7%BD%91%E3%80%91%E6%82%A8%E7%9A%84%E9%AA%8C%E8%AF%81%E7%A0%81%E6%98%AF1234&amp;apikey=d25fbaa9ed5025eef7b777ca73c56af3”(text输出格式为unicode)。 urllib2.urlopen()创建一个表示远程url的类文件对象，然后像本地文件一样操作这个类文件对象来获取远程数据。当只传入url参数时，该函数将使用HTTP GET向url发送请求,当同时传入url和data参数时，该函数则使用HTTP POST方法向url发送请求。返回为一个类文件对象，该对象提供如下方法： read(), readline(), readlines(), fileno(), close()：这些方法的使用方式与文件对象完全一样，读者可以自行了解python对于文件对象的处理； info()：返回一个httplib.HTTPMessage对象，表示远程服务器返回的头信息； getcode()：返回HTTP状态码； geturl()：返回请求的url； 代码进阶对于以上的代码urllib2也能做到，而且在使用上几乎没有区别，那么这里我们对代码进行一些修改： # -*- coding: utf-8 -*- import urllib2 import urllib url = &quot;http://yunpian.com/v1/sms/send.json&quot; data = urllib.urlencode({&apos;apikey&apos;: &quot;***********************&quot;, &apos;mobile&apos;: &apos;****************&apos;, &apos;text&apos;: &quot;【云片网】您的验证码是1234&quot;}) req = urllib2.Request(url, data) response = urllib2.urlopen(req) print response.read() 其中我们引入了Request对象，并且直接在urllib2.urlopen()中传入Request对象，代码依旧能执行。在python官方的urllib2文档中，有这么一句话“Open the URL url, which can be either a string or a Request object.” 对于传入的url参数，可以直接是字符串，也可以是Request对象，而在urllib之中没有这种用法。 对于Request对象，我们可以通过它来修改 HTTP 请求的 header 和 proxy，这个我们在之后的文章会讲解，这里先提出这个用法，以免在以后的使用和介绍中显得突兀。 以上代码的最终结果是一个json字符串，使用type()方法返回值为str。可以使用python的json库，使用json.loads()将json字符串转换为数据原本的格式，本例的最终原本的数据为字典。 有了以上的基础，我们可以尝试实现一个简单的模拟登录 什么是模拟登录在很多网站上都会有一套用户系统，那么肯定就免除不了会有登录操作，并且许多信息和操作只有在登录之后才能实现。目前网站上判断用户是否登录有大概两种方式： 使用cookie来对应记录用户的登录状态以及有效时间 自定义一个token，发送给已经登录的用户，里面存储了用户的一些信息已经登录状态有效时间 这两种方式的思想都大同小异吧，目前我们主要对使用cookie进行登录判定的网站举例讲解。 需要准备的工具用户抓包的工具：chrome、firefox的firebug插件。至于抓包工具如何使用，大家可以自行搜索。 抓包首先我们需要通过抓包工具获取如下三个信息： post请求的网址 post请求的参数 post请求的返回值 然后我们就针对以上获取到的数据进行下一步操作 代码实现以电子科技大学的信息门户登录为例，需要用到的包:urllib，urllib2，cookielib # -*- coding: utf-8 -*- import urllib import cookielib import urllib2 loginUrl = &quot;https://uis.uestc.edu.cn/amsever/UI/Login&quot; postUrl = &quot;https://uis.uestc.edu.cn/amserver/UI/Login&quot; # 初始化一个CookieJar来处理cookie信息 cookieJar = cookielib.CookieJar() # 初始化一个opener cJHandler = urllib2.HTTPCookieProcessor(cookieJar) opener = urllib2.build_opener(cJHandler, urllib2.HTTPHandler) urllib2.install_opener(opener) # 用get请求访问网站，获取必要的cookie值 res1 = opener.open(loginUrl) # 用post请求向url提交表单 postData = {&quot;IDToken0&quot;: &quot;&quot;, # 登录用户名 &quot;IDToken1&quot;: &quot;这里填写你的登录用户名&quot;, # 登录密码 &quot;IDToken2&quot;: &quot;这里填写你的登录密码&quot;, &quot;IDButton&quot;: &quot;Submit&quot;, &quot;goto&quot;: &quot;aHR0cDovL3BvcnRhbC51ZXN0Yy5lZHUuY24vbG9naW4ucG9ydGFs&quot;, &quot;encoded&quot;: &quot;true&quot;, &quot;gx_charset&quot;: &quot;UTF-8&quot;} postData = urllib.urlencode(postData).encode(encoding=&apos;UTF8&apos;) req = urllib2.Request(postUrl, postData) response = opener.open(req) print response.read() 不出意外的话，打印的结果就是登录成功后返回的网页。 代码讲解相对于之前的爬虫代码，这里多了一个cookie的管理，所以我们使用了cookielib包来生成一个CookieJar对象来自动处理返回的cookie值。 之后我们需要将获取到的cookie值写入我们的每一次http请求中，于是我们使用了urllib2.build_opener()来生成一个OpenerDirector对象，而在一个OpenerDirector里面有很多的处理类，我们称之为handler。这些handler可以帮我们完善我们的http请求，比如本例中的向http请求中加入获取到的cookie。在调用了urllib2.builde_opener()之后，我们需要再调用urllib2.install_opener()来将生成的OpenerDirector实例化，这样在之后我们就可以使用OpenerDirector的open方法来代替urllib2.urlopen()方法了(当然你之后继续使用urllib2.urlopen()也不会有问题) 在模拟登录操作成功之后，我们就可以通过get或者post请求直接访问获取我们登录后才能看到的信息了，如个人学籍信息等，不过一定要使用urllib2.urlopen()或者OpenerDirector.open()方法来发送请求，因为我们之后的操作必须使用到我们之前登录成功获取到的cookie值，所以我们必须用我们生成的OpenerDirector对象的open方法来发送请求（其实urllib2.urlopen()也是默认调用当前OpenerDirector对象的open()方法）。 结语对于模拟登录的方法，实现方式不止以上的一种，不过基本思想都是一致的。归根结底就是用户先向服务器发送需要认证的信息，然后服务器返回给你一个身份标识，之后用户每次向服务器发送请求的时候，都将这个身份标识一起发给服务器，向服务器证明你是一个登录的合法用户，然后服务器返回给用户应该看到的和想看到的数据。","categories":[{"name":"Python","slug":"Python","permalink":"https://shadowwood.me/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://shadowwood.me/tags/python/"},{"name":"网络爬虫","slug":"网络爬虫","permalink":"https://shadowwood.me/tags/网络爬虫/"}]}]}