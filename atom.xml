<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ShadowWood&#39;s Blog</title>
  <subtitle>睡睡觉，玩玩游戏编编程</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://shadowwood.me/"/>
  <updated>2017-04-03T16:25:38.000Z</updated>
  <id>https://shadowwood.me/</id>
  
  <author>
    <name>Shadow Wood</name>
    <email>shadowwood@foxmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>express源码分析</title>
    <link href="https://shadowwood.me/2016/08/27/2016-08-27-express-origin-code-analysis/"/>
    <id>https://shadowwood.me/2016/08/27/2016-08-27-express-origin-code-analysis/</id>
    <published>2016-08-27T13:00:00.000Z</published>
    <updated>2017-04-03T16:25:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>express是node.js的一个轻量级后端框架，本文将对express的源码实现逻辑及主要服务的实现方式做一些分析</p>
<a id="more"></a>
<h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><p>直接<code>npm install express</code>，可以看到express的包结构如下：</p>
<pre><code>├── lib
│   ├── middleware
│   │   ├── init.js
│   │   └── query.js
│   ├── router
│   │   ├── index.js
│   │   ├── layer.js
│   │   └── route.js
│   ├── application.js
│   ├── express.js
│   ├── request.js
│   ├── response.js
│   ├── utils.js
│   └── view.js
├── History.md
├── index.js
├── LICENSE
├── package.json
└── Readme.md
</code></pre><p>express模块的入口是 index.js，该文件中又引入了./lib/express.js，并将其用module.exports导出。</p>
<h2 id="express-js"><a href="#express-js" class="headerlink" title="express.js"></a>express.js</h2><p><code>lib/express.js</code>是对express所有定义及功能模块的整合，该文件的开头如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>).EventEmitter;</div><div class="line"><span class="keyword">var</span> mixin = <span class="built_in">require</span>(<span class="string">'merge-descriptors'</span>);</div><div class="line"><span class="keyword">var</span> proto = <span class="built_in">require</span>(<span class="string">'./application'</span>);</div><div class="line"><span class="keyword">var</span> Route = <span class="built_in">require</span>(<span class="string">'./router/route'</span>);</div><div class="line"><span class="keyword">var</span> Router = <span class="built_in">require</span>(<span class="string">'./router'</span>);</div><div class="line"><span class="keyword">var</span> req = <span class="built_in">require</span>(<span class="string">'./request'</span>);</div><div class="line"><span class="keyword">var</span> res = <span class="built_in">require</span>(<span class="string">'./response'</span>);</div><div class="line"></div><div class="line">exports = <span class="built_in">module</span>.exports = createApplication;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createApplication</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> app = <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</div><div class="line">		app.handle(req, res, next);</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	mixin(app, EventEmitter.prototype, <span class="literal">false</span>);</div><div class="line">	mixin(app, proto, <span class="literal">false</span>);</div><div class="line"></div><div class="line">	<span class="comment">// expose the prototype that will get set on requests</span></div><div class="line">  app.request = <span class="built_in">Object</span>.create(req, &#123;</div><div class="line">    app: &#123; <span class="attr">configurable</span>: <span class="literal">true</span>, <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">writable</span>: <span class="literal">true</span>, <span class="attr">value</span>: app &#125;</div><div class="line">  &#125;)</div><div class="line"></div><div class="line">	<span class="comment">// expose the prototype that will get set on responses</span></div><div class="line">  app.response = <span class="built_in">Object</span>.create(res, &#123;</div><div class="line">    app: &#123; <span class="attr">configurable</span>: <span class="literal">true</span>, <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">writable</span>: <span class="literal">true</span>, <span class="attr">value</span>: app &#125;</div><div class="line">  &#125;)</div><div class="line"></div><div class="line">	app.init();</div><div class="line">	<span class="keyword">return</span> app;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>文件一开始便引入了一些基础模块，基本来说根据这些模块的引入基本对express结构基本有一些理解了，之后的分析思路也会沿着这些引入的文件来进行。<br>先大概介绍下这些模块做了哪些事情：</p>
<ul>
<li>EventEmitter: node.js的events模块</li>
<li>mixin: 用来合并对象的工具</li>
<li>proto: express应用的原型对象，在application.js里详细定义</li>
<li>Route: 定义最基本Route对象，包括app.post,app.all等以及Router对象的http方法都是从这里继承的</li>
<li>Router: 完整的Router对象，继承了Route的http方法，也集合了./router/layer.js下的路由初始化方法及路由处理方法，相当于是路由功能的整合</li>
<li>req: request对象</li>
<li>res: response对象</li>
</ul>
<p>在引入了这些模块之后，就有了整个express的应用创建方法<code>createApplication</code>，也相当于是express的一个main函数。<br>在<code>createApplication</code>函数中一开始就把需要返回的值<code>app</code>定义为一个函数，该函数有<code>req</code>, <code>res</code>, <code>next</code>三个参数，这不得不使人联想起app.get(‘/‘, function(req, res, next) {})里的req,res,next。在这个函数的内部则直接调用<code>app</code>的handle方法，并将<code>req</code>,<code>res</code>,<code>next</code>作为参数传入其中。<br><code>app.handle</code>这个方法是在<code>./application</code>中定义的并通过mixin将该方法合并到app对象上。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">app.handle = <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">req, res, callback</span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> router = <span class="keyword">this</span>._router;</div><div class="line"></div><div class="line">	<span class="comment">// final handler</span></div><div class="line">	<span class="keyword">var</span> done = callback || finalhandler(req, res, &#123;</div><div class="line">		env: <span class="keyword">this</span>.get(<span class="string">'env'</span>),</div><div class="line">		onerror: logerror.bind(<span class="keyword">this</span>)</div><div class="line">	&#125;);</div><div class="line"></div><div class="line">	<span class="comment">// no routes</span></div><div class="line">	<span class="keyword">if</span> (!router) &#123;</div><div class="line">		debug(<span class="string">'no routes defined on app'</span>);</div><div class="line">		done();</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	router.handle(req, res, done);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>该方法的作用是将res, res逐级分发到express应用每个路由中，以便执行各个路由相匹配的操作。<br>其实这个函数最关键的部分是在router.handle(req, res, done)这个方法的执行上，这是真正的路由分发执行操作，在./router/index.js里面定义，之后会对这部分进行分析讲解。</p>
<p>接着createApplication里的操作。在定义了app之后，执行了两个<code>mixin</code>方法，分别将 <code>EventEmitter</code> 和 <code>./application.js</code> 中的属性和方法合并到<code>app</code>之中。</p>
<p>在 mixin 之后，createApplicaion 又使用了对象字面量的定义方法，定义了<code>app.request</code>和<code>app.response</code>对象，分别以 <code>./request.js</code> 和 <code>./response.js</code>为原型对象，并赋值app属性且指向app本身(这里是为了在之后的response对象或request对象中，能够使用this.app访问已经创建的express实例)。</p>
<p>然后就是执行<code>app.init()</code>，这个<code>init()</code>方法也是在<code>./application.js</code>中定义的，用来初始化express应用的设置</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">app.init = <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">this</span>.cache = &#123;&#125;;</div><div class="line">	<span class="keyword">this</span>.engines = &#123;&#125;;</div><div class="line">	<span class="keyword">this</span>.settings = &#123;&#125;;</div><div class="line"></div><div class="line">	<span class="keyword">this</span>.defaultConfiguration();</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在createApplicaion的最后返回组建好的<code>app</code>对象。</p>
<p>在createApplicaion之后，便是一些公共API的导出：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">exports.application = proto;</div><div class="line">exports.request = req;</div><div class="line">exports.response = res;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* Expose constructors.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"></div><div class="line">exports.Route = Route;</div><div class="line">exports.Router = Router;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* Expose middleware</span></div><div class="line"><span class="comment">*/</span></div><div class="line"></div><div class="line">exports.query = <span class="built_in">require</span>(<span class="string">'./middleware/query'</span>);</div><div class="line">exports.static = <span class="built_in">require</span>(<span class="string">'serve-static'</span>);</div></pre></td></tr></table></figure></p>
<p>对于这些公共api模块的功能和作用也不多说了，express的文档有相应的说明。</p>
<p>在<code>./express.js</code>的最后，遍历了一个数组：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">	<span class="string">'json'</span>,</div><div class="line">	<span class="string">'urlencoded'</span>,</div><div class="line">	<span class="string">'bodyParser'</span>,</div><div class="line">	<span class="string">'compress'</span>,</div><div class="line">	<span class="string">'cookieSession'</span>,</div><div class="line">	<span class="string">'session'</span>,</div><div class="line">	<span class="string">'logger'</span>,</div><div class="line">	<span class="string">'cookieParser'</span>,</div><div class="line">	<span class="string">'favicon'</span>,</div><div class="line">	<span class="string">'responseTime'</span>,</div><div class="line">	<span class="string">'errorHandler'</span>,</div><div class="line">	<span class="string">'timeout'</span>,</div><div class="line">	<span class="string">'methodOverride'</span>,</div><div class="line">	<span class="string">'vhost'</span>,</div><div class="line">	<span class="string">'csrf'</span>,</div><div class="line">	<span class="string">'directory'</span>,</div><div class="line">	<span class="string">'limit'</span>,</div><div class="line">	<span class="string">'multipart'</span>,</div><div class="line">	<span class="string">'staticCache'</span>,</div><div class="line">].forEach(<span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</div><div class="line">	<span class="built_in">Object</span>.defineProperty(exports, name, &#123;</div><div class="line">		get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Most middleware (like '</span> + name + <span class="string">') is no longer bundled with Express and must be installed separately. Please see https://github.com/senchalabs/connect#middleware.'</span>);</div><div class="line">		&#125;,</div><div class="line">		configurable: <span class="literal">true</span></div><div class="line">	&#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这是因为express 4.x之后，很多中间件依赖没有在express内部导入了，但是express有时会用到这些中间件，这里是一个中间件检测，告诉开发者数组内的中间件需要从外部install进来。</p>
<h2 id="router"><a href="#router" class="headerlink" title="router"></a>router</h2><p>./router文件夹下包括三个文件：</p>
<ul>
<li><code>layer.js</code>：定义中间件的基本数据结构</li>
<li><code>route.js</code>：定义express的路由中间件Route;</li>
<li><code>index.js</code>：定义一个中间件容器，也就是Router对象，用来存放路由中间件(Route)以及其他功能中间件</li>
</ul>
<blockquote>
<p><code>Router</code> 和 <code>Route</code> 的区别：Router可以看作是一个中间件容器，不仅可以存放路由中间件（Route），还可以存放其他中间件；而Route仅仅是路由中间件，封装了路由信息。<br>Router和Route都各自维护了一个stack数组，该数组就是用来存放中间件和路由的。</p>
</blockquote>
<h3 id="layer-js"><a href="#layer-js" class="headerlink" title="layer.js"></a>layer.js</h3><p>首先来看layer.js中对于中间件的初始定义：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> pathRegexp = <span class="built_in">require</span>(<span class="string">'path-to-regxp'</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Layer</span>(<span class="params">path, options, fn</span>) </span>&#123;</div><div class="line">	<span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> Layer)) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Layer(path, options, fn)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	debug(<span class="string">'new %s'</span>, path);</div><div class="line">	<span class="keyword">var</span> opts = options || &#123;&#125;;</div><div class="line"></div><div class="line">	<span class="keyword">this</span>.handle = fn;</div><div class="line">	<span class="keyword">this</span>.name = fn.name || <span class="string">'&lt;anonymous&gt;'</span>;</div><div class="line">	<span class="keyword">this</span>.params = <span class="literal">undefined</span>;</div><div class="line">	<span class="keyword">this</span>.path = <span class="literal">undefined</span>;</div><div class="line">	<span class="keyword">this</span>.regexp = pathRegexp(path, <span class="keyword">this</span>.keys = [], opts);</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (path === <span class="string">'/'</span> &amp;&amp; opts.end === <span class="literal">false</span>) &#123;</div><div class="line">		<span class="keyword">this</span>.regexp.fast_slash = <span class="literal">true</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>path</code>参数不用多说，就是传入的url字符串，这里使用了<code>path-to-regexp</code>这个库，用来匹配url字符串，<code>options</code>是<code>path-to-regexp</code>需要的配置参数，即为 {sensitive: Boolean, stric: Boolean, end: Boolean}。npm上有该库的详细使用说明，这里就不再讲解了。<br><code>fn</code>也就是中间件里的回调处理函数，在Layer初始化的时候将它赋值给了自己的<code>handle</code>属性。</p>
<p>之后Layer还定义了三个操作方法：<code>handle_error</code>, <code>handle_request</code>, <code>match</code>。</p>
<p><code>handle_error</code>就是定义的express应用中的错误处理部分，例如app.use(fuction(err, req, res, next){})最后就会执行到这里。<br><code>handle_request</code>定义的就是express应用中的路由中间件请求处理函数，也就是例如app.get(‘/test’, function(req, res, next){})的操作最后的执行位置。<br><code>match</code>定义的是匹配<code>path</code>参数的操作，使用<code>path-to-regexp</code>的操作方法，例如在请求过程中<code>/foo/23</code>与就会和之前定义的<code>/foo/:id</code>相匹配，并最终将对应的<code>23</code>赋值<code>req.params.id</code>，这一部分的操作需要结合<code>path-to-regexp</code>的操作方法去了解。</p>
<p>整个Layer的定义其实并不复杂，它定义了中间件的基本数据结构，是后面Router和Route对象实现的基础。</p>
<h3 id="route-js"><a href="#route-js" class="headerlink" title="route.js"></a>route.js</h3><p>同样，先从Route对象的初始化入手：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Route</span>(<span class="params">path</span>) </span>&#123;</div><div class="line">	<span class="keyword">this</span>.path = path;</div><div class="line">	<span class="keyword">this</span>.stack = [];</div><div class="line"></div><div class="line">	debug(<span class="string">'new %s'</span>, path);</div><div class="line"></div><div class="line">	<span class="keyword">this</span>.methods = &#123;&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>path</code>参数不用多说，<code>stack</code>是一个存放layer组件的数组，<code>methods</code>是存放HTTP方法的Object，例如{‘get’: true, ‘post’: true}，即表示该Route中间件只能接受get和post方法。</p>
<p>紧接着Route通过原型链的方式定义了两个与<code>methods</code>紧密相关的方法：</p>
<ul>
<li>_handles_method: 判断Route对象中是否存在method(传入参数)方法，并且如果method值为<code>head</code>，当作get方法处理；</li>
<li>_options：返回Route对象的methods值，并且如果存在<code>get</code>，则再添加一个<code>head</code>值。</li>
</ul>
<p>然后就是比较重要的部分，中间件的派发操作：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">Route.prototype.dispatch = <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">req, res, done</span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> idx = <span class="number">0</span>;</div><div class="line">	<span class="keyword">var</span> stack = <span class="keyword">this</span>.stack;</div><div class="line">	<span class="keyword">if</span> (stack.length === <span class="number">0</span>) &#123;</div><div class="line">		<span class="keyword">return</span> done();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">var</span> method = req.method.toLowerCase();</div><div class="line">	<span class="keyword">if</span> (method === <span class="string">'head'</span> &amp;&amp; !<span class="keyword">this</span>.methods[<span class="string">'head'</span>]) &#123;</div><div class="line">		method = <span class="string">'get'</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	req.route = <span class="keyword">this</span>;</div><div class="line"></div><div class="line">	next();</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">		<span class="keyword">if</span> (err &amp;&amp; err === <span class="string">'route'</span>) &#123;</div><div class="line">			<span class="keyword">return</span> done();</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">var</span> layer = stack[idx++];</div><div class="line">		<span class="keyword">if</span> (!layer) &#123;</div><div class="line">			<span class="keyword">return</span> done(err);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (layer.method &amp;&amp; layer.method !== method) &#123;</div><div class="line">			<span class="keyword">return</span> next(err);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (err) &#123;</div><div class="line">			layer.handle_error(err, req, res, next);</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			layer.handle_request(req, res, next);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在知道了<code>layer</code>和<code>stack</code>这两个事物的基础上，这个函数的操作流程就很好理解了，其实就是通过函数递归的方法，对Route对象的<code>stack</code>按插入顺序进行遍历，然后依次执行<code>stack</code>里的<code>layer</code>的过程。<br>当然，首先<code>req.method</code>也就是请求的http方法必须在Route对象中的methods之中。</p>
<p>最后就是定义如何调用Route对应的HTTP方法,也就是<code>router.get</code>,<code>router.post</code>等最终执行的地方</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">Route.prototype.all = <span class="function"><span class="keyword">function</span> <span class="title">all</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> handles = flatten(slice.call(<span class="built_in">arguments</span>));</div><div class="line"></div><div class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; handles.length; i++) &#123;</div><div class="line">		<span class="keyword">var</span> handle = handles[i];</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (<span class="keyword">typeof</span> handle !== <span class="string">'function'</span>) &#123;</div><div class="line">			<span class="keyword">var</span> type = toString.call(handle);</div><div class="line">			<span class="keyword">var</span> msg = <span class="string">'Route.all() requires callback functions but got a '</span> + type;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(msg);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">var</span> layer = Layer(<span class="string">'/'</span>, &#123;&#125;, handle);</div><div class="line">		layer.method = <span class="literal">undefined</span>;</div><div class="line"></div><div class="line">		<span class="keyword">this</span>.methods._all = <span class="literal">true</span>;</div><div class="line">		<span class="keyword">this</span>.stack.push(layer);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">methods.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">method</span>)</span>&#123;</div><div class="line">	Route.prototype[method] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="keyword">var</span> handles = flatten(slice.call(<span class="built_in">arguments</span>));</div><div class="line"></div><div class="line">		<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; handles.length; i++) &#123;</div><div class="line">			<span class="keyword">var</span> handle = handles[i];</div><div class="line"></div><div class="line">			<span class="keyword">if</span> (<span class="keyword">typeof</span> handle !== <span class="string">'function'</span>) &#123;</div><div class="line">				<span class="keyword">var</span> type = toString.call(handle);</div><div class="line">				<span class="keyword">var</span> msg = <span class="string">'Route.'</span> + method + <span class="string">'() requires callback functions but got a '</span> + type;</div><div class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(msg);</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			debug(<span class="string">'%s %s'</span>, method, <span class="keyword">this</span>.path);</div><div class="line"></div><div class="line">			<span class="keyword">var</span> layer = Layer(<span class="string">'/'</span>, &#123;&#125;, handle);</div><div class="line">			layer.method = method;</div><div class="line"></div><div class="line">			<span class="keyword">this</span>.methods[method] = <span class="literal">true</span>;</div><div class="line">			<span class="keyword">this</span>.stack.push(layer);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">	&#125;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>两个代码块一个是定义了<code>Route.all</code>,一个是通过遍历<code>methods</code>(require(‘methods’)，存储了各种HTTP请求方法)将其中的元素赋值到成Route对象的属性，也就有了<code>Route.get</code>,<code>Route.post</code>等方法。<br>其实这两个代码块其中的执行流程都大同小异。<br>在这里需要注意的是定义<code>Route.method</code>(这里method指代all,get,post等)时，其中第一行代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> handles = flatten(slice.call(<span class="built_in">arguments</span>));</div></pre></td></tr></table></figure>
<p>这里的handles就是app.get(‘/path’, fn1, fn2, fn3)中的<code>fn1</code>,<code>fn2</code>,<code>fn3</code>等，也就是中间件的回调函数。<br>但是如果这样使用，有人会问不应该是slice.call(arguments, 1)，也就是从第二个参数开始截取吗？(slice 是 Array.prototype.slice，在route.js开头定义的)<br>刚开始看到这里的时候，笔者也有这个疑问，后来在index.js里面，也就是定义Router对象的地方，找到这么一段代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">proto.route = <span class="function"><span class="keyword">function</span> <span class="title">route</span>(<span class="params">path</span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> route = <span class="keyword">new</span> Route(path);</div><div class="line"></div><div class="line">	<span class="keyword">var</span> layer = <span class="keyword">new</span> Layer(path, &#123;</div><div class="line">		sensitive: <span class="keyword">this</span>.caseSensitive,</div><div class="line">		strict: <span class="keyword">this</span>.strict,</div><div class="line">		end: <span class="literal">true</span></div><div class="line">	&#125;, route.dispatch.bind(route));</div><div class="line"></div><div class="line">	layer.route = route;</div><div class="line"></div><div class="line">	<span class="keyword">this</span>.stack.push(layer);</div><div class="line">	<span class="keyword">return</span> route;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// create Router#VERB functions</span></div><div class="line">methods.concat(<span class="string">'all'</span>).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">method</span>)</span>&#123;</div><div class="line">	proto[method] = <span class="function"><span class="keyword">function</span>(<span class="params">path</span>)</span>&#123;</div><div class="line">		<span class="keyword">var</span> route = <span class="keyword">this</span>.route(path)</div><div class="line">		route[method].apply(route, slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>));</div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">	&#125;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这里可以看出Route是被放在了Router的<code>stack</code>里的<code>layer.route</code>，然后在调用类似Router[method](path, fn1, fn2)的时候，已经将其中path提取出来，并且直接通过调用<code>this.route(path)</code>赋值到<code>Route</code>中的<code>path</code>属性，之后将<code>fn1</code>,<code>fn2</code>通过<code>slice.call(arguments,1)</code>的方式截取出来，使用route[method].apply调用到Route.method方法。<br>所以在Route.method调用的时候，其arguments已经是回调函数<code>fn1</code>，<code>fn2</code>等的数组了。</p>
<p>OK，解决了这个疑问，继续下一个重点，可以看见在Route.method的定义中，最终都返回了<code>this</code>，加上之前对于arguments的处理，就形成了路由中间件的灵活调用方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">router.get(<span class="string">'/path'</span>, fn1, fn2, fn3);</div><div class="line"></div><div class="line">router.get(<span class="string">'/path'</span>, [fn1, [fn2, [fn3]]]);</div><div class="line"></div><div class="line">router.get(<span class="string">'/path'</span>, fn1).get(<span class="string">'/path'</span>, fn2).get(<span class="string">'/path'</span>, fn3);</div></pre></td></tr></table></figure>
<p>这三个最终实现的结果是一样的，第一个和第二个没有什么区别，第三个有些许不一样，第一个和第二个在Router中’fn1,fn2,fn3’都是在同一个layer.route之中，而第三个则是在不同的layer.route之中。<br>第一个和第二个是通过遍历Route的stack来找到fn进行执行，而第三个是遍历Router的stack来找到fn进行执行。简单来说就是一个放在外层的stack，一个放在内层的stack。</p>
<p>其实在route.js这部分必须要结合index.js来看，不然对于一些实现方法不是很好理解。</p>
<h3 id="index-js"><a href="#index-js" class="headerlink" title="index.js"></a>index.js</h3><p>老规矩，还是先从导出对象的基本定义开始。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> proto = <span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> opts = options || &#123;&#125;;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">function</span> <span class="title">router</span>(<span class="params">req, res, next</span>) </span>&#123;</div><div class="line">		router.handle(req, res, next);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// mixin Router class functions</span></div><div class="line">  setPrototypeOf(router, proto);</div><div class="line"></div><div class="line">	router.params = &#123;&#125;;</div><div class="line">	router._params = [];</div><div class="line">	router.caseSensitive = opts.caseSensitive;</div><div class="line">	router.mergeParams = opts.mergeParams;</div><div class="line">	router.strict = opts.strict;</div><div class="line">	router.stack = [];</div><div class="line"></div><div class="line">	<span class="keyword">return</span> router;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这里的初始化定义应该不难看懂，options参数就是<code>pathRegexp</code>要求的三个配置参数<code>caseSensitive</code>,<code>mergeParams</code>,<code>strict</code>。<br><code>router.stack</code>前面也解释得比较多了，这里也不再赘述。<code>router.params</code>和<code>router._params</code>是定义app.params(param, fn)中会使用到存储对象。<br>需要注意的是Router最终返回的是 <code>router.handle(req,res,next)</code>的执行函数，<code>router.handle</code>是定义的Router中的路由派发操作，类似Route.dispatch，之后这里会详细解释。</p>
<p>在这之后在Router对象上定义了param(name, fn)方法，这其实就是app.param(name, fn)定义的部分，这部分会在appliction.js绑定到app.param上，也就成了express文档里的app.param。这部分没有什么难以理解的地方，结合文档看基本可以理解，所以这里就跳过proto.param(name, fn)。</p>
<p>之后就是在Router的初始化里提到过的router.handle的定义：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">proto.handle = <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">req, res, out</span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> self = <span class="keyword">this</span>;</div><div class="line"></div><div class="line">	debug(<span class="string">'dispatching %s %s'</span>, req.method, req.url);</div><div class="line"></div><div class="line">	<span class="keyword">var</span> search = <span class="number">1</span> + req.url.indexOf(<span class="string">'?'</span>);</div><div class="line">	<span class="keyword">var</span> pathlength = search ? search - <span class="number">1</span> : req.url.length;</div><div class="line">	<span class="keyword">var</span> fqdn = req.url[<span class="number">0</span>] !== <span class="string">'/'</span> &amp;&amp; <span class="number">1</span> + req.url.substr(<span class="number">0</span>, pathlength).indexOf(<span class="string">'://'</span>);</div><div class="line">	<span class="keyword">var</span> protohost = fqdn ? req.url.substr(<span class="number">0</span>, req.url.indexOf(<span class="string">'/'</span>, <span class="number">2</span> + fqdn)) : <span class="string">''</span>;</div><div class="line">	<span class="keyword">var</span> idx = <span class="number">0</span>;</div><div class="line">	<span class="keyword">var</span> removed = <span class="string">''</span>;</div><div class="line">	<span class="keyword">var</span> slashAdded = <span class="literal">false</span>;</div><div class="line">	<span class="keyword">var</span> paramcalled = &#123;&#125;;</div><div class="line"></div><div class="line">	<span class="comment">// store options for OPTIONS request</span></div><div class="line">	<span class="comment">// only used if OPTIONS request</span></div><div class="line">	<span class="keyword">var</span> options = [];</div><div class="line"></div><div class="line">	<span class="comment">// middleware and routes</span></div><div class="line">	<span class="keyword">var</span> stack = self.stack;</div><div class="line"></div><div class="line">	<span class="comment">// manage inter-router variables</span></div><div class="line">	<span class="keyword">var</span> parentParams = req.params;</div><div class="line">	<span class="keyword">var</span> parentUrl = req.baseUrl || <span class="string">''</span>;</div><div class="line">	<span class="keyword">var</span> done = restore(out, req, <span class="string">'baseUrl'</span>, <span class="string">'next'</span>, <span class="string">'params'</span>);</div><div class="line"></div><div class="line">	<span class="comment">// setup next layer</span></div><div class="line">	req.next = next;</div><div class="line"></div><div class="line">	<span class="comment">// for options requests, respond with a default if nothing else responds</span></div><div class="line">	<span class="keyword">if</span> (req.method === <span class="string">'OPTIONS'</span>) &#123;</div><div class="line">		done = wrap(done, <span class="function"><span class="keyword">function</span>(<span class="params">old, err</span>) </span>&#123;</div><div class="line">			<span class="keyword">if</span> (err || options.length === <span class="number">0</span>) <span class="keyword">return</span> old(err);</div><div class="line">			sendOptionsResponse(res, options, old);</div><div class="line">		&#125;);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// setup basic req values</span></div><div class="line">	req.baseUrl = parentUrl;</div><div class="line">	req.originalUrl = req.originalUrl || req.url;</div><div class="line"></div><div class="line">	next();</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">		<span class="comment">/**next 定义，暂时省略 **/</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">function</span> <span class="title">trim_prefix</span>(<span class="params">layer, layerError, layerPath, path</span>) </span>&#123;</div><div class="line">		<span class="comment">/**暂时省略 **/</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为这部分加上内部定义的函数的话，代码量比较多，一下贴出来不太容易理清思路，所以先将<code>next</code>和<code>trim_prefix</code>函数省略(<code>trim_prefix</code>是在<code>next</code>内部调用的)，先看看handle大概做了一件什么事情。<br>之前也说过<code>router.handle</code>是派发req和res到每个路由中间件的操作，联系之前提到的Route中的<code>dispatch</code>方法是通过函数调用的方法来遍历<code>stack</code>的中间件实现的req和res的派发，所以这里也是用了同样的操作：“通过递归调用<code>next</code>来实现路由派发”。<br>但是在调用next()之前，<code>router.handle</code>对<code>req.url</code>也就是原始的url进行了处理，把请求协议和search参数以及host都提取了出来，所以可以理解为在派发路由前，先对url做了一个预处理操作。</p>
<p>接下来就是仔细看一下看<code>next</code>函数是具体定义了一个怎么样的操作：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> layerError = err === <span class="string">'route'</span></div><div class="line">		? <span class="literal">null</span></div><div class="line">		: err;</div><div class="line"></div><div class="line">	<span class="comment">// remove added slash</span></div><div class="line">	<span class="keyword">if</span> (slashAdded) &#123;</div><div class="line">		req.url = req.url.substr(<span class="number">1</span>);</div><div class="line">		slashAdded = <span class="literal">false</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// restore altered req.url</span></div><div class="line">	<span class="keyword">if</span> (removed.length !== <span class="number">0</span>) &#123;</div><div class="line">		req.baseUrl = parentUrl;</div><div class="line">		req.url = protohost + removed + req.url.substr(protohost.length);</div><div class="line">		removed = <span class="string">''</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// no more matching layers</span></div><div class="line">	<span class="keyword">if</span> (idx &gt;= stack.length) &#123;</div><div class="line">		setImmediate(done, layerError);</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// get pathname of request</span></div><div class="line">	<span class="keyword">var</span> path = getPathname(req);</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (path == <span class="literal">null</span>) &#123;</div><div class="line">		<span class="keyword">return</span> done(layerError);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// find next matching layer</span></div><div class="line">	<span class="keyword">var</span> layer;</div><div class="line">	<span class="keyword">var</span> match;</div><div class="line">	<span class="keyword">var</span> route;</div><div class="line"></div><div class="line">	<span class="keyword">while</span> (match !== <span class="literal">true</span> &amp;&amp; idx &lt; stack.length) &#123;</div><div class="line">		layer = stack[idx++];</div><div class="line">		match = matchLayer(layer, path);</div><div class="line">		route = layer.route;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (<span class="keyword">typeof</span> match !== <span class="string">'boolean'</span>) &#123;</div><div class="line">			<span class="comment">// hold on to layerError</span></div><div class="line">			layerError = layerError || match;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (match !== <span class="literal">true</span>) &#123;</div><div class="line">			<span class="keyword">continue</span>;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (!route) &#123;</div><div class="line">			<span class="comment">// process non-route handlers normally</span></div><div class="line">			<span class="keyword">continue</span>;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (layerError) &#123;</div><div class="line">			<span class="comment">// routes do not match with a pending error</span></div><div class="line">			match = <span class="literal">false</span>;</div><div class="line">			<span class="keyword">continue</span>;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">var</span> method = req.method;</div><div class="line">		<span class="keyword">var</span> has_method = route._handles_method(method);</div><div class="line"></div><div class="line">		<span class="comment">// build up automatic options response</span></div><div class="line">		<span class="keyword">if</span> (!has_method &amp;&amp; method === <span class="string">'OPTIONS'</span>) &#123;</div><div class="line">			appendMethods(options, route._options());</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">// don't even bother matching route</span></div><div class="line">		<span class="keyword">if</span> (!has_method &amp;&amp; method !== <span class="string">'HEAD'</span>) &#123;</div><div class="line">			match = <span class="literal">false</span>;</div><div class="line">			<span class="keyword">continue</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// no match</span></div><div class="line">	<span class="keyword">if</span> (match !== <span class="literal">true</span>) &#123;</div><div class="line">		<span class="keyword">return</span> done(layerError);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// store route for dispatch on change</span></div><div class="line">	<span class="keyword">if</span> (route) &#123;</div><div class="line">		req.route = route;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// Capture one-time layer values</span></div><div class="line">	req.params = self.mergeParams</div><div class="line">		? mergeParams(layer.params, parentParams)</div><div class="line">		: layer.params;</div><div class="line">	<span class="keyword">var</span> layerPath = layer.path;</div><div class="line"></div><div class="line">	<span class="comment">// this should be done for the layer</span></div><div class="line">	self.process_params(layer, paramcalled, req, res, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</div><div class="line">		<span class="keyword">if</span> (err) &#123;</div><div class="line">			<span class="keyword">return</span> next(layerError || err);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (route) &#123;</div><div class="line">			<span class="keyword">return</span> layer.handle_request(req, res, next);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		trim_prefix(layer, layerError, layerPath, path);</div><div class="line">	&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里主要关注一下stack的遍历操作。在<code>next</code>之中stack的遍历先是通过while循环判断<code>match</code>值来确定是否找到匹配的<code>layer</code>, <code>match</code>是通过调用<code>matchLayer</code>返回结果，该方法定义为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">matchLayer</span>(<span class="params">layer, path</span>) </span>&#123;</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		<span class="keyword">return</span> layer.match(path);</div><div class="line">	&#125; <span class="keyword">catch</span>(err) &#123;</div><div class="line">		<span class="keyword">return</span> err;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实就是调用<code>layer.match</code>，只是加了个try catch而已。</p>
<p>如果while循环如果找到了匹配的layer，那么会就会调用<code>proto.process_params</code>的方法，也就是self.process_params()这部操作；</p>
<p><code>proto.process_params</code>的源码这里就不贴出来了，了解一下操作流程就好。这个方法需要对应<code>proto.param</code>来理解，其实就是<strong><em>查询并调用</em></strong><code>proto.param</code>里面<strong><em>定义且匹配的</em></strong>与<code>req.param</code>绑定的function，这些回调函数都是存储在<code>proto.params</code>里面的，所以这里就又会有一个通过函数递归的遍历操作。<br>在遍历完了之后就是调用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</div><div class="line">		<span class="keyword">if</span> (err) &#123;</div><div class="line">			<span class="keyword">return</span> next(layerError || err);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (route) &#123;</div><div class="line">			<span class="keyword">return</span> layer.handle_request(req, res, next);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		trim_prefix(layer, layerError, layerPath, path);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果<code>layer.route</code>是存在的，结合之前分析的<code>Layer</code>和<code>Route</code>以及在Route的分析中提前提到这部分后面定义的<code>Router.route</code>，也就是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">proto.route = <span class="function"><span class="keyword">function</span> <span class="title">route</span>(<span class="params">path</span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> route = <span class="keyword">new</span> Route(path);</div><div class="line"></div><div class="line">	<span class="keyword">var</span> layer = <span class="keyword">new</span> Layer(path, &#123;</div><div class="line">		sensitive: <span class="keyword">this</span>.caseSensitive,</div><div class="line">		strict: <span class="keyword">this</span>.strict,</div><div class="line">		end: <span class="literal">true</span></div><div class="line">	&#125;, route.dispatch.bind(route));</div><div class="line"></div><div class="line">	layer.route = route;</div><div class="line"></div><div class="line">	<span class="keyword">this</span>.stack.push(layer);</div><div class="line">	<span class="keyword">return</span> route;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>layer.handle_request</code>会执行<code>layer.route</code>的<code>dispatch</code>操作，也就是在Route中派发路由最终执行到在express中定义的对应的路由操作函数，之后又执行<code>next()</code>就又到了这里的<code>proto.stack</code>中的下一个遍历操作。<br>但是如果<code>layer.route</code>不存在，说明这只是一个中间件而不是路由中间件，也就是用<code>route.use</code>定义的中间件，所以就调用<code>trim_prefix</code>方法来执行路由中间件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">trim_prefix</span>(<span class="params">layer, layerError, layerPath, path</span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> c = path[layerPath.length];</div><div class="line">	<span class="keyword">if</span> (c &amp;&amp; <span class="string">'/'</span> !== c &amp;&amp; <span class="string">'.'</span> !== c) <span class="keyword">return</span> next(layerError);</div><div class="line"></div><div class="line">		<span class="comment">// Trim off the part of the url that matches the route</span></div><div class="line">		<span class="comment">// middleware (.use stuff) needs to have the path stripped</span></div><div class="line">	<span class="keyword">if</span> (layerPath.length !== <span class="number">0</span>) &#123;</div><div class="line">		debug(<span class="string">'trim prefix (%s) from url %s'</span>, layerPath, req.url);</div><div class="line">		removed = layerPath;</div><div class="line">		req.url = protohost + req.url.substr(protohost.length + removed.length);</div><div class="line"></div><div class="line">		<span class="comment">// Ensure leading slash</span></div><div class="line">		<span class="keyword">if</span> (!fqdn &amp;&amp; req.url[<span class="number">0</span>] !== <span class="string">'/'</span>) &#123;</div><div class="line">			req.url = <span class="string">'/'</span> + req.url;</div><div class="line">			slashAdded = <span class="literal">true</span>;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">// Setup base URL (no trailing slash)</span></div><div class="line">		req.baseUrl = parentUrl + (removed[removed.length - <span class="number">1</span>] === <span class="string">'/'</span></div><div class="line">			? removed.substring(<span class="number">0</span>, removed.length - <span class="number">1</span>)</div><div class="line">			: removed);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	debug(<span class="string">'%s %s : %s'</span>, layer.name, layerPath, req.originalUrl);</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (layerError) &#123;</div><div class="line">		layer.handle_error(layerError, req, res, next);</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		layer.handle_request(req, res, next);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法是在<code>proto.handle</code>里定义，和<code>next</code>同级。</p>
<p>OK，这里再回到while，如果while循环没有找到匹配的layer就进行收尾工作，要么就根据layerError也就是next(err)中的err参数判断是否已经匹配到结果正常首尾，或者就是404没找到匹配。</p>
<p>分析到这里，这里使用两张图对上面的分析进行一个整理。</p>
<p>首先是layer,Route和Router这三者的关系（原图片来自文章<a href="https://cnodejs.org/topic/545720506537f4d52c414d87" target="_blank" rel="external">从express源码中探析其路由机制</a>）</p>
<p><img src="http://7xu027.com1.z0.glb.clouddn.com/router_route_layer.png" alt="layer,Route,Router"></p>
<p>然后是<code>proto.handle</code>的一个执行流程：</p>
<p><img src="http://7xu027.com1.z0.glb.clouddn.com/express_router_handle.png" alt="proto.handle"></p>
<p>有了这两张图，再配合之前的文字描述，应该对路由这部分的处理不会有什么问题了。</p>
<h2 id="request-和-response"><a href="#request-和-response" class="headerlink" title="request 和 response"></a>request 和 response</h2><p>先说request.js，这里是定义app.method(path, function(req, res, next) {}) 中 req对象的地方，首先先看req对象初始化</p>
<pre><code>var req = Object.create(http.IncommingMessage.prototype);
</code></pre><p>req是以http.IncommingMessage的原型创建的对象，也就是说http.IncommingMessage该有的事件和方法，req都是有的，并且req也是一个<code>Readable Stream</code>，如果要具体了解，可以去看看<a href="https://nodejs.org/api/http.html#http_class_http_incomingmessage" target="_blank" rel="external">http.IncommingMessage的文档</a></p>
<p>在这个文件里面express文档中关于req的方法都在这里有对应的定义，并且也不难读，所以这里也就不再多说。</p>
<p>值得一提的是req.params, req.query和req.body都不是在这里初始化和定义的：</p>
<ul>
<li>req.params: 之前在介绍layer.js的时候提到过，req.params是在中间件匹配的过程中生成的，这个params对象先是在layer中初始化并且通过<code>path-to-regexp</code>匹配生成键值对，然后再router/index.js定义Router的handle方法的里，将params值赋给req:</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">proto.handle = <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">req, res, out</span>) </span>&#123;</div><div class="line">  <span class="comment">/* 省略 */</span></div><div class="line"></div><div class="line">	<span class="comment">// Capture one-time layer values</span></div><div class="line">	req.params = self.mergeParams</div><div class="line">		? mergeParams(layer.params, parentParams)</div><div class="line">		: layer.params;</div><div class="line">	<span class="comment">/* 省略 */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>req.query: 这里的可以去看middleware/query.js 中，首先这里定义了query函数中间件，然后在application.js里面定义的lazyrouter方法里，以router.use方法调用这个query函数中间件:</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">app.lazyrouter = <span class="function"><span class="keyword">function</span> <span class="title">lazyrouter</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>._router) &#123;</div><div class="line">    <span class="keyword">this</span>._router = <span class="keyword">new</span> Router(&#123;</div><div class="line">      caseSensitive: <span class="keyword">this</span>.enabled(<span class="string">'case sensitive routing'</span>),</div><div class="line">      strict: <span class="keyword">this</span>.enabled(<span class="string">'strict routing'</span>)</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="keyword">this</span>._router.use(query(<span class="keyword">this</span>.get(<span class="string">'query parser fn'</span>)));</div><div class="line">    <span class="keyword">this</span>._router.use(middleware.init(<span class="keyword">this</span>));</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>而这个lazyrouter方法呢只要是使用了app.use或者app.get, app.post等都会调用，所以req.query是在这个时候生成的。</p>
<ul>
<li>req.body: 现在这个对象已经不再express处理了，主要是因为<code>body-parser</code>已经从express里依赖的包里面独立出去了，所以这部分的处理可以去看<code>body-parser</code>这个包，当然req.body也是在中间件中生成的；</li>
</ul>
<p>然后我们再来看response.js，这里是定义app.method(path, function(req, res, next) {})中的res的地方，首先是res的初始化:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> res = <span class="built_in">Object</span>.create(http.ServerResponse.prototype);</div></pre></td></tr></table></figure>
<p>res是以http.ServerResponse的原型创建的对象，也就是说http.ServerResponse的事件和方法基本也适用于它，并且也是一个<code>Writable Stream</code>对象。res相对于req就要简单一些，在express文档里面提到的方法在这里都是在这里定义的，所以也不再多说了。</p>
<h2 id="application"><a href="#application" class="headerlink" title="application"></a>application</h2><p>application.js, 这里就是定义初始化express应用的地方，也就是express.js中的express应用的proto定义的地方，里面也定义了express()返回的对象里面可使用的各个方法，阅读起来难度也不大。</p>
<p>总的来说application.js算是一个集大成所在的地方了，这里也是express应用对象定义的入口，在分析完各个部分之后，再在application这里看一遍整理一下，应该就比较清楚整个express是什么样的结构了。</p>
<p>本来这里有一个lazyrouter方法应该说一下，但是在分析req.query的时候已经提到过了，这里就不再赘述了。</p>
<h2 id="从请求到响应"><a href="#从请求到响应" class="headerlink" title="从请求到响应"></a>从请求到响应</h2><p>以创建一个express服务为例</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> responseTime = <span class="built_in">require</span>(<span class="string">'response-time'</span>);</div><div class="line"><span class="keyword">const</span> cookieParser = <span class="built_in">require</span>(<span class="string">'cookie-parser'</span>);</div><div class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">'body-parser'</span>);</div><div class="line"><span class="keyword">const</span> expressSession = <span class="built_in">require</span>(<span class="string">'express-session'</span>);</div><div class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</div><div class="line"><span class="keyword">const</span> compression = <span class="built_in">require</span>(<span class="string">'compression'</span>);</div><div class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line"><span class="keyword">const</span> router = <span class="built_in">require</span>(<span class="string">'../routes'</span>);</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">const</span> app = express();</div><div class="line"></div><div class="line"><span class="keyword">const</span> resolve = <span class="function"><span class="params">file</span> =&gt;</span> path.resolve(__dirname, file);</div><div class="line"></div><div class="line">app.use(compression());</div><div class="line">app.use(responseTime());</div><div class="line">app.use(bodyParser.json(&#123;<span class="attr">limit</span>: <span class="string">'10mb'</span>&#125;));</div><div class="line">app.use(bodyParser.urlencoded(&#123;<span class="attr">limit</span>: <span class="string">'10mb'</span>, <span class="attr">parameterLimit</span>: <span class="number">100000</span>, <span class="attr">extended</span>: <span class="literal">false</span>&#125;));</div><div class="line">app.use(cookieParser());</div><div class="line"></div><div class="line">app.use(router);</div><div class="line"></div><div class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</div><div class="line">  next(&#123;<span class="attr">status</span>: <span class="string">'pageNotFound'</span>, <span class="attr">code</span>: <span class="number">404</span>&#125;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">app.listen(<span class="number">8000</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'start up!'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>app.listen方法在application.js里面有定义：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">app.listen = <span class="function"><span class="keyword">function</span> <span class="title">listen</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> server = http.createServer(<span class="keyword">this</span>);</div><div class="line">  <span class="keyword">return</span> server.listen.apply(server, <span class="built_in">arguments</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>关于http.createServer在官方文档里有说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">http.createServer([requestListener])</div><div class="line">Added in: v0.1.13</div><div class="line">requestListener &lt;Function&gt;</div><div class="line"></div><div class="line">Returns: &lt;http.Server&gt;</div><div class="line"></div><div class="line">Returns a new instance of http.Server.</div><div class="line"></div><div class="line">The requestListener is a function which is automatically added to the &apos;request&apos; event.</div></pre></td></tr></table></figure>
<p>而app(req, res, next)的执行时直接调用的app.handle(req, res, next)方法，也就是在express.js中的createApplication中定义的:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createApplication</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> app = <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</div><div class="line">    app.handle(req, res, next);</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="comment">/* 省略 */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>app.handle()一执行就是直接按照之前app中定义好的中间件顺序进行匹配并且执行了，整个express服务也就这样开始一步一步处理请求，直到最后res对象发送请求到客户端。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章由于笔者的拖延症，整整拖了半年左右才写完，不过最重要的部分也就是中间件那部分的内容是一开始就完成了的。</p>
<p>由于完成的事件跨度较大，所以express的代码有部分的更新变动可能会导致此文章贴出的源码前后会有一些差异，不过总的实现方法和思想倒是没啥变化。</p>
<p>express是一个非常轻量的框架，用来实现一些微服务特别便利，但是如果要用来做企业级的应用和服务的话，就需要制定许多约束或者说是规范。笔者也正在这方面努力踩坑=。=。</p>
]]></content>
    
    <summary type="html">
    
      express是node.js的一个轻量级后端框架，本文将对express的源码实现逻辑及主要服务的实现方式做一些分析
    
    </summary>
    
      <category term="Javascript" scheme="https://shadowwood.me/categories/Javascript/"/>
    
    
      <category term="javascript" scheme="https://shadowwood.me/tags/javascript/"/>
    
      <category term="node.js" scheme="https://shadowwood.me/tags/node-js/"/>
    
      <category term="express" scheme="https://shadowwood.me/tags/express/"/>
    
  </entry>
  
  <entry>
    <title>Promise的简单实现</title>
    <link href="https://shadowwood.me/2016/08/12/2016-08-12-acherive-promise/"/>
    <id>https://shadowwood.me/2016/08/12/2016-08-12-acherive-promise/</id>
    <published>2016-08-12T02:08:00.000Z</published>
    <updated>2017-02-21T15:53:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Promise是js的一个异步流程控制标准，是为了解决js中异步回调过多导致的代码结构混乱的问题。<br>Promise标准已经被写入了ES6的语法中，ES6已经有了原生的Promise对象。之前对async和promise的使用做了一个简单的对比，为了更好的理解Promise对异步回调的一个控制流程，这次根据Promise/A+规范实现一个简单的Promise。</p>
<a id="more"></a>
<h3 id="Promise-A"><a href="#Promise-A" class="headerlink" title="Promise/A+"></a>Promise/A+</h3><p>Promise/A+是一个开放、健全且通用的Javascript Promise标准，是由Javascript的开发者制定的，以供其他开发者参考。</p>
<ul>
<li><a href="https://promisesaplus.com/" target="_blank" rel="external">Promise/A+英文原文</a></li>
<li><a href="http://malcolmyu.github.io/malnote/2015/06/12/Promises-A-Plus/" target="_blank" rel="external">Promise/A+中文解读</a></li>
</ul>
<p>上面是关于Promise/A+规范的资料，这里就不再对Promise/A+规范做进一步的解读了。</p>
<h3 id="初始化Promise对象"><a href="#初始化Promise对象" class="headerlink" title="初始化Promise对象"></a>初始化Promise对象</h3><p>首先定义一个Promise对象：</p>
<pre><code>function Promise(fn) {
    var __self = {
        status: &apos;Pending&apos;,
        value: undefined,
        options: [&apos;Pending&apos;, &apos;Resolved&apos;, &apos;Rejected&apos;]
    }
}
</code></pre><p>在这个Promise对象之中，定义了一个私有变量__self:</p>
<ul>
<li>__self.status: 该值用来存储该Promise对象当前的状态</li>
<li>__self.value: 该值用来存储Promise的终值(resolved时的value)或者拒绝的原因(rejected时的reason)</li>
<li>__self.options: 该值为三个状态值的数组</li>
</ul>
<p>因为Promise/A+中规定，Promise对象状态一旦处于resolved或者rejected，其状态和值便不能更改，所以其状态值和终值必须存储在私有变量中，防止外部对其进行操作更改。</p>
<p>但是这些私有变量也会涉及到值的更改，而且这些更改操作不一定在对象内部定义。所以在Promise对象定义的时候还需要定义一些set和get方法：</p>
<pre><code>function Promise(fn) {
    var __self = {
        status: &apos;Pending&apos;,
        value: undefined,
        options: [&apos;Pending&apos;, &apos;Resolved&apos;, &apos;Rejected&apos;]
    }

    var self = this;

    self.__getStatus = function () {
        return __self.status
    }

    self.__setStatus = function (val) {
        var index = __self.options.indexOf(val);
        if (index === -1 || __self.status === &apos;Resolved&apos; || __self.status === &apos;Rejected&apos;) {
            return false;
        }

        __self.status = val;
        return true;
    }

    self.__getValue = function () {
        return __self.value
    }

    self.__setValue = function () {
        if (__self.status === &apos;Pending&apos;) {
            __self.value = val;
            return true;
        } else {
            return false;
        }
    }

}
</code></pre><p>首先是status的get和set函数，get函数直接返回__self.status的值，而在set函数之中则需要加一些限制。<br>在Promise/A+标准中规定状态(status)的更改只能是从pending到resolved或者rejected，当状态为resolved或者rejcted的时候，便不能再更改状态。</p>
<p>然后是value的get和set函数，get函数同理直接返回__self.value，而在set函数之中，要求只能是状态为pending的时候才能对值进行修改，否则修改无效。</p>
<h3 id="resolve和reject"><a href="#resolve和reject" class="headerlink" title="resolve和reject"></a>resolve和reject</h3><p>在Promise对象实例化的时候，其参数函数中(例如的Promise对象参数fn)有两个参数: resolve和reject。<br>这两个参数是Promise对象实例化执行结束时调用的回调函数：</p>
<ul>
<li>resolve(value): 在执行成功时调用，将Promise对象的状态修改为resolved并且终值修改为传入的value</li>
<li>reject(err): 在执行成功时调用，将Promise对象的状态修改为rejected并且将拒绝原因修改为传入的err</li>
</ul>
<p>这两个函数既可以定义在Promise对象外面，也可以定义在Promise对象里面。<br>当定义的Promise对象外面的时在之后执行的时候需要使用.bind(this)方法将Promise对象的this传入，所以其最终结果和定义在内部没有多少差异，所以这里还是采用定义在内部的方式：</p>
<pre><code>function Promise(fn) {
    var __self = {
        status: &apos;Pending&apos;,
        value: undefined,
        options: [&apos;Pending&apos;, &apos;Resolved&apos;, &apos;Rejected&apos;]
    }

    var self = this;

    self.onResolvedCallback = []; // Promise resolved 的回调函数集
    self.onRejectedCallback = []; // Promise rejected 的回调函数集


    /*****此处省略了之前的status和value的set和get函数******/

    function resovle (val) {
        self.__setValue(val);
        self.__setStatus(&apos;Fulfilled&apos;)
        for (var i = 0; i &lt; self.onResolvedCallback.length; i++) {
            self.onResolvedCallback[i](val);
        }
    }

    function reject (err) {
        if (!err) {
            return ;
        }
        self.__setValue(err);
        self.__setStatus(&apos;Rejected&apos;);
        for (var i = 0; i &lt; self.onRejectedCallback.length; i++) {
            self.onRejectedCallback[i](err);
        }
    }

    try {
        fn(resolve, reject)
    } catch (err) {
        reject(err)
    }

}
</code></pre><p>注意这次加入了两个特别的值，<code>onResolvedCallback</code> 和 <code>onRejectedCallback</code>，分别用来存储 Promise 对象 revolved 和 rejected 时的回调函数。<br>至于为什么需要使用这两个值以及这两个值实现了什么功能，这个在之后的构建.then方法的时候再详细解释。</p>
<p>其实<code>resolve</code>和<code>reject</code>两个操作流程基本是一致的，都进行了三步操作：</p>
<ol>
<li>设置终值或拒绝原因;</li>
<li>修改状态为<code>Resovled</code>或 <code>Rejected</code></li>
<li>遍历回调函数集并执行回调函数；</li>
</ol>
<p>这两者操作的区别只在于状态值和回调函数集不同，所以这两个函数完全可以合并成一个操作函数。这里只是为了语义更清晰一点，这里还是决定分开写。<br>之后直接执行Promise对象的fn参数函数，并且传入<code>resovle</code> 和 <code>reject</code> 当作fn的参数，之后在fn内部执行回调。<br>注意，这里执行fn的时候必须使用try catch捕捉错误并执行reject，因为完全可能在fn的执行过程中出现错误，这一部分也需要在Promise对象里捕捉到。</p>
<p>这里的<code>resolve</code>和<code>reject</code>还存在一个缺陷，就是在遍历<code>onRejectedCallback</code>和<code>onResolvedCallback</code>的时候可能会花费较大部分的时间，所以应该采用异步的写法，即加入setTimeout将其操作流程改成异步的:</p>
<pre><code>function resovle (val) {
    setTimeout(function() {
        self.__setValue(val);
        self.__setStatus(&apos;Fulfilled&apos;)
        for (var i = 0; i &lt; self.onResolvedCallback.length; i++) {
            self.onResolvedCallback[i](val);
        }
    })
}

function reject (err) {
    if (!err) {
        return ;
    }
    setTimeout(function() {
        self.__setValue(err);
        self.__setStatus(&apos;Rejected&apos;);
        for (var i = 0; i &lt; self.onRejectedCallback.length; i++) {
            self.onRejectedCallback[i](err);
        }
    })
}
</code></pre><h3 id="then方法"><a href="#then方法" class="headerlink" title=".then方法"></a>.then方法</h3><p><code>Promise</code>的<code>.then</code>方法是<code>Promise</code>对象的核心部分之一，可以说这个链式法则是Promise广受推崇的一个重要原因吧。<br>对于<code>.then</code>方法，有几个重点要特别注意:</p>
<ul>
<li><code>.then</code>方法返回的是一个Promise对象；</li>
<li><code>.then</code>方法有两个参数<code>onResolved</code>和<code>onRejected</code>，分别为Promise状态为Resolved和Rejected时的回调函数；</li>
<li><code>.then</code>方法可以在Promise还未执行完成的时候就开始执行，也就是说当Promise为<code>Pending</code>状态的时候，<code>.then</code>方法也可以执行；</li>
</ul>
<p>针对以上几个要点，这里先从调用<code>.then</code>方法时Promise已经Resovled来实现：</p>
<pre><code>Promise.prototype.then = function (onResolved, onRejected) {
    onResolved = typeof onResolved === &apos;function&apos; ? onResolved : function (v) { return v };
    onRejected = typeof onRejected === &apos;function&apos; ? onRejected : function (e) { throw e };
    var self = this;
    var status = self.__getStatus();
    var value = self.__getValue();

    if (status === &apos;Pending&apos;) {
        return new Promise(function (resolve, reject) {
            try {
                var x = onResolved(value);
                if (x instanceof Promise) {
                    x.then(resolve, reject)
                } else {
                    resolve(x)
                }
            } catch (e) {
                reject(e)
            }
        })
    }
}
</code></pre><p>首先判断传入的参数<code>onResolved</code>和<code>onRejected</code>是否是函数，如果不是则分别默认为 <code>function (v) { return v }</code> 和 <code>function (e) { throw e }</code>，以便实现值的穿透(后面详细介绍)。<br>然后获取到当前Promise对象的<code>status</code> 和 <code>value</code>，并返回一个新的Promise对象，在新的Promise对象中，执行<code>onResolved</code>函数。<br>之后判断<code>onResolved</code>函数的返回值是否为Promise对象，如果是Promise对象，直接调用其<code>.then</code>方法并传入<code>resolve</code>和<code>reject</code>做为其<code>onResolved</code>和<code>onRejected</code>参数，如果不是则直接执行<code>resolve</code>。<br>在这个操作流程之中，需要使用<code>try catch</code>包装代码块并将捕捉到的错误传入<code>reject</code>执行，因为完全可能在执行<code>onResolved</code>的过程中出现错误而阻止后续代码的执行。</p>
<p>当执行<code>.then</code>方法时Promise对象状态为<code>Rejected</code>的时候操作流程基本一致，只是将<code>onResovled</code>替换成<code>onRejected</code>就行了。<br>所以这里可以将生成新的Promise对象内部的操作流程写成一个新的函数：</p>
<pre><code>function thenDeal(fn, value, resolve, reject) {
    try {
        var x = fn(value);
        if (x instanceof Promise) {
            x.then(resolve, reject)
        } else {
            resolve(x)
        }
    } catch (e) {
        reject(e)
    }
}
</code></pre><p>这个函数可以写在<code>.then</code>方法外面并直接调用：</p>
<pre><code>Promise.prototype.then = function (onResolved, onRejected) {
    onResolved = typeof onResolved === &apos;function&apos; ? onResolved : function (v) { return v };
    onRejected = typeof onRejected === &apos;function&apos; ? onRejected : function (e) { throw e };
    var self = this;
    var status = self.__getStatus();
    var value = self.__getValue();
    switch (status) {
        case &apos;Resolved&apos;:
            return new Promise(function (resolve, reject) {
                thenDeal(onResolved, value, resolve, reject)
            })

        case &apos;Rejected&apos;:
            return new Promise(function (resolve, reject) {
                thenDeal(onRejected, value, resolve, reject)
            })
    }
}
</code></pre><p>接下来就是需要考虑当<code>.then</code>方法执行时，Promise对象还是<code>Pending</code>状态的情况了，这里就需要用到之前定义的回调函数集合<code>onResolvedCallback</code>和<code>onRejectedCallback</code>。<br>其实思路也并不复杂，只是需要注意一些值的调用，先给出完整的实现方法：</p>
<pre><code>Promise.prototype.then = function (onResolved, onRejected) {
    onResolved = typeof onResolved === &apos;function&apos; ? onResolved : function (v) { return v };
    onRejected = typeof onRejected === &apos;function&apos; ? onRejected : function (e) { throw e };
    var self = this;
    var status = self.__getStatus();
    var value = self.__getValue();
    switch (status) {
        case &apos;Pending&apos;:
            return new Promise(function (resolve, reject) {
                self.onResolvedCallback.push(function () {
                    thenDeal(onResolved, self.__getValue(), resolve, reject)
                });
                self.onRejectedCallback.push(function () {
                    thenDeal(onRejected, self.__getValue(), resolve, reject)
                })
            });
        case &apos;Revolved&apos;:
            return new Promise(function (resolve, reject) {
                thenDeal(onResolved, value, resolve, reject)
            })

        case &apos;Rejected&apos;:
            return new Promise(function (resolve, reject) {
                thenDeal(onRejected, value, resolve, reject)
            })
    }
}

function thenDeal(fn, value, resolve, reject) {
    try {
        var x = fn(value);
        if (x instanceof Promise) {
            x.then(resolve, reject)
        } else {
            resolve(x)
        }
    } catch (e) {
        reject(e)
    }
}
</code></pre><p>在<code>Pending</code>状态的时候，因为完全不清楚Promise最终的执行结果是<code>Resolved</code>还是<code>Rejected</code>，所以需要把<code>onResolved</code>和<code>onRejected</code>分别弄进<code>onResolvedCallback</code>和<code>onRejectedCallback</code>里，以传入回调函数的形式最终在里面执行<code>thenDeal</code>。<br>这里需要注意一个特别的点，那就是<code>thenDeal</code>的value参数(即<code>Resolved</code>时的<code>value</code>或<code>Rejected</code>时的<code>reason</code>)必须是实时的Promise对象的值，即Promise的终值或拒绝原因，这部分和之前的<code>Resolved</code>及<code>Rejected</code>状态时的处理方式不同。</p>
<p><code>.catch</code>可以直接用<code>.then</code>方法来定义：</p>
<pre><code>Promise.prototype.catch = function(onRejected) {
    return this.then(null, onRejected)
}
</code></pre><p>对于这两行代码：</p>
<pre><code>onResolved = typeof onResolved === &apos;function&apos; ? onResolved : function (v) { return v };
onRejected = typeof onRejected === &apos;function&apos; ? onRejected : function (e) { throw e };
</code></pre><p>条件判断的作用就不解释了，至于为什么要有<code>function (v) {return v}</code>和<code>function (e) {throw e}</code>的默认值，是为了实现Promise <code>.then</code>方法的值传递。例如：</p>
<pre><code>var p = new Promise((resolve, reject) =&gt; resolve(1));
p.then()
 .then(v =&gt; {
     console.log(1);
     throw(2);
  })
 .then()
 .catch(e =&gt; console.log(e))
</code></pre><p>该代码的最终输出结果为 1 和 2。</p>
<h3 id="Promise的解决过程"><a href="#Promise的解决过程" class="headerlink" title="Promise的解决过程"></a>Promise的解决过程</h3><p>在之前的<code>.then</code>方法实现里面的<code>thenDeal</code>方法是直接通过判断 <code>x instanceof Promise</code>来确实返回值是否是Promise对象，这种实现不符合Promise/A+规范的，并且无法和其他Promise交互。<br>在 <code>Promise/A+</code> 的2.3部分定义了Promise .then方法里的解决过程，并且阐述了<code>thenable</code>特性。原文翻译为：</p>
<blockquote>
<p>Promise解决过程是一个抽象的操作，其需输入一个<code>promise</code>和一个值，我们表示为 <code>[[Resolve]](promise, x)</code>，如果 <code>x</code> 有 <code>then</code> 方法且看上去像一个 <code>Promise</code> ，解决程序即尝试使 <code>promise</code> 接受 <code>x</code> 的状态；否则其用 <code>x</code> 的值来执行 <code>promise</code>。</p>
</blockquote>
<p>根据这个标准，需要加入一个<code>promiseResovle</code>方法来实现Promise解决过程，首先先明确这个<code>promiseResovle</code>方法的在之前的Promise实现需要插入的位置：</p>
<pre><code>Promise.prototype.then = function (onResolved, onRejected) {
    onResolved = typeof onResolved === &apos;function&apos; ? onResolved : function (v) { return v };
    onRejected = typeof onRejected === &apos;function&apos; ? onRejected : function (e) { throw e };
    var self = this;
    var status = self.__getStatus();
    var value = self.__getValue();
    switch (status) {
        case &apos;Pending&apos;:
            return promise2 = new Promise(function (resolve, reject) {
                self.onResolvedCallback.push(function () {
                    thenDeal(onResolved, self.__getValue(), resolve, reject, promise2)
                });
                self.onRejectedCallback.push(function () {
                    thenDeal(onRejected, self.__getValue(), resolve, reject, promise2)
                })
            });
        case &apos;Revolved&apos;:
            return promise2 = new Promise(function (resolve, reject) {
                setTimeout(function () {
                    thenDeal(onResolved, value, resolve, reject, promise2)
                })
            })

        case &apos;Rejected&apos;:
            return promise2 = new Promise(function (resolve, reject) {
                setTimeout(function () {
                    thenDeal(onRejected, value, resolve, reject, promise2)
                })
            })
    }
}

function thenDeal(fn, value, resolve, reject, promise) {
    try {
        var x= fn(value);
        promiseResovle(promise, x, resolve, reject);
    } catch (e) {
        reject(e)
    }
}
</code></pre><p>相较于之前的代码，主要在<code>thenDeal</code>进行了修改，传入了即将返回的Promise对象<code>promise2</code>，并且将其传入<code>promiseResovle</code>中。<br><code>promiseResovle</code>的功能是对<code>onResolved</code>或者<code>onRejected</code>的返回值进行处理解决，使其能实现多种Promise的交互。</p>
<p>根据<code>Promise/A+</code>的规定，<code>promiseResovle</code>需要依次判断三种情况：</p>
<ol>
<li>参数 <code>x</code> 与 参数 <code>promise</code> 相等时；</li>
<li>参数 <code>x</code> 为 Promise(即自己定义的Promise，不是通用的或者其他的Promise对象)；</li>
<li>参数 <code>x</code> 为对象或者函数；</li>
</ol>
<p>下面依次实现着三种情况的判断和要求。</p>
<h4 id="参数-x-与-参数-promise-相等"><a href="#参数-x-与-参数-promise-相等" class="headerlink" title="参数 x 与 参数 promise 相等"></a>参数 <code>x</code> 与 参数 <code>promise</code> 相等</h4><p><code>Promise/A+</code>中规定，当参数 <code>x</code> 与 参数 <code>promise</code> 相等时，以<code>TypeError</code>为<code>reason</code>拒绝执行<code>promise</code>，实现代码如下：</p>
<pre><code>function promiseResovle(promise, r, resolve, reject) {

    if (r === promise) {
        return reject(new TypeError(&apos;The promise has been circular used&apos;))
    }
}
</code></pre><h4 id="参数-x-为-Promise"><a href="#参数-x-为-Promise" class="headerlink" title="参数 x 为 Promise"></a>参数 <code>x</code> 为 Promise</h4><p>接着当 <code>x</code>为Promise时：</p>
<ul>
<li>如果 <code>x</code> 处于等待态， <code>promise</code> 需保持为等待态直至 <code>x</code> 被执行或拒绝</li>
<li>如果 <code>x</code> 处于执行态，用相同的值执行 <code>promise</code></li>
<li>如果 <code>x</code> 处于拒绝态，用相同的据因拒绝 <code>promise</code></li>
</ul>
<p>接着之前的实现：</p>
<pre><code>function promiseResovle(promise, r, resolve, reject) {

    if (r === promise) {
        return reject(new TypeError(&apos;The promise has been circular used&apos;))
    }

    if (r instanceof Promise) {
        var status = r.__getStatus();
        if (status === &apos;Pending&apos;) {
            r.then(function(value) {
                promiseResovle(promise, value, resolve, reject)
            }, reject)
        } else {
            r.then(resolve, reject)
        }

        return ;
    }
}
</code></pre><p>当 <code>x</code> 处于 <code>Pending</code>状态的时候，调用 <code>x</code> 的 <code>.then</code> 方法并在其中再次调用<code>promiseResolve</code>以待获取 <code>x</code> 的终值或拒因；<br>当 <code>x</code> 处于 <code>onRejected</code> 或者 <code>onResolved</code> 的时候，就可以直接执行 <code>x.then</code> 并传入 <code>resolve</code> 和 <code>reject</code> 来执行 <code>promise</code>；</p>
<h4 id="参数-x-为对象或者函数"><a href="#参数-x-为对象或者函数" class="headerlink" title="参数 x 为对象或者函数"></a>参数 <code>x</code> 为对象或者函数</h4><p>当 <code>x</code> 为对象或者函数的时候，<code>Promise/A+</code>规定操作方法及顺序如下：</p>
<ol>
<li>把 <code>x.then</code> 赋值给 <code>then</code></li>
<li>如果取 <code>x.then</code> 的值时抛出错误 <code>e</code> ，则以 <code>e</code> 为据因拒绝 <code>promise</code></li>
<li>如果 <code>then</code> 是函数，将 <code>x</code> 作为函数的作用域 <code>this</code> 调用之。传递两个回调函数作为参数，第一个参数叫做 <code>resolvePromise</code> ，第二个参数叫做 <code>rejectPromise</code>:<ul>
<li>如果 <code>resolvePromise</code> 以值 <code>y</code> 为参数被调用，则运行 <code>[[Resolve]](promise, y)</code></li>
<li>如果 <code>rejectPromise</code> 以据因 <code>r</code> 为参数被调用，则以据因 <code>r</code> 拒绝 promise</li>
<li>如果 <code>resolvePromise</code> 和 <code>rejectPromise</code> 均被调用，或者被同一参数调用了多次，则优先采用首次调用并忽略剩下的调用</li>
<li>如果调用 <code>then</code> 方法抛出了异常 <code>e</code>：<ul>
<li>如果 <code>resolvePromise</code> 或 <code>rejectPromise</code> 已经被调用，则忽略之</li>
<li>否则以 <code>e</code> 为据因拒绝 <code>promise</code></li>
</ul>
</li>
</ul>
</li>
<li>如果 <code>then</code> 不是函数，以 <code>x</code> 为参数执行 <code>promise</code></li>
<li>如果 <code>x</code> 不为对象或者函数，以 <code>x</code> 为参数执行 promise</li>
</ol>
<p>根据上述的规定，加上之前的实现，最终<code>promiseResolve</code>的定义如下：</p>
<pre><code>function promiseResovle(promise, x, resolve, reject) {
    var then;
    var thenCalled = false;

    if (x === promise) {
        return reject(new TypeError(&apos;The promise has been circular used&apos;))
    }

    if (x instanceof Promise) {
        var status = x.__getStatus();
        if (status === &apos;Pending&apos;) {
            x.then(function(value) {
                promiseResovle(promise, value, resolve, reject)
            }, reject)
        } else {
            x.then(resolve, reject)
        }

        return ;
    }

    function resolvePromise(y) {
        if(thenCalled) return;
        thenCalled = true;
        promiseResolve(promise, y, resolve, reject)
    }

    function rejectPromise(r) {
        if (thenCalled) return;
        thenCalled = true;
        reject(r)
    }

    if(x !== null &amp;&amp; (typeof x === &apos;Object&apos; || typeof x === &apos;function&apos;)) {
        try {
            then = x.then;
            if (typeof then === &apos;function&apos;) {
                then.call(x, resolvePromise, rejectPromise)
            } else {
                resolve(x)
            }
        } catch (e) {
            reject(e)
        }
    } else {
        resolve(x)
    }
}
</code></pre><h3 id="完整版"><a href="#完整版" class="headerlink" title="完整版"></a>完整版</h3><p>最后，贴出完整版的Promise实现：</p>
<pre><code>function Promise(fn) {
    var __self = {
        status: &apos;Pending&apos;,
        value: undefined,
        options: [&apos;Pending&apos;, &apos;Resolved&apos;, &apos;Rejected&apos;]
    }

    var self = this;

    self.onResolvedCallback = []; // Promise resolved 的回调函数集
    self.onRejectedCallback = []; // Promise rejected 的回调函数集


    /*****status和value的set和get函数******/

    self.__getStatus = function () {
        return __self.status
    }

    self.__setStatus = function (val) {
        var index = __self.options.indexOf(val);
        if (index === -1 || __self.status === &apos;Resolved&apos; || __self.status === &apos;Rejected&apos;) {
            return false;
        }

        __self.status = val;
        return true;
    }

    self.__getValue = function () {
        return __self.value
    }

    self.__setValue = function () {
        if (__self.status === &apos;Pending&apos;) {
            __self.value = val;
            return true;
        } else {
            return false;
        }
    }

    /*********END**********/

    /*******resolve 和 reject *******/

    function resovle (val) {
        setTimeout(function() {
            self.__setValue(val);
            self.__setStatus(&apos;Fulfilled&apos;)
            for (var i = 0; i &lt; self.onResolvedCallback.length; i++) {
                self.onResolvedCallback[i](val);
            }
        })
    }

    function reject (err) {
        if (!err) {
            return ;
        }
        setTimeout(function() {
            self.__setValue(err);
            self.__setStatus(&apos;Rejected&apos;);
            for (var i = 0; i &lt; self.onRejectedCallback.length; i++) {
                self.onRejectedCallback[i](err);
            }
        })
    }

    /***********END**********/

    try {
        fn(resolve, reject)
    } catch (err) {
        reject(err)
    }

}

Promise.prototype.then = function (onResolved, onRejected) {
    /*************定义回调函数集************/
    onResolved = typeof onResolved === &apos;function&apos; ? onResolved : function (v) { return v };
    onRejected = typeof onRejected === &apos;function&apos; ? onRejected : function (e) { throw e };
    /************END************/
    var self = this;
    var status = self.__getStatus();
    var value = self.__getValue();

    switch (status) {

        case &apos;Pending&apos;:
            return promise2 = new Promise(function (resolve, reject) {
                self.onResolvedCallback.push(function () {
                    thenDeal(onResolved, self.__getValue(), resolve, reject, promise2)
                });
                self.onRejectedCallback.push(function () {
                    thenDeal(onRejected, self.__getValue(), resolve, reject, promise2)
                })
            });

        case &apos;Revolved&apos;:
            return promise2 = new Promise(function (resolve, reject) {
                setTimeout(function () {
                    thenDeal(onResolved, value, resolve, reject, promise2)
                })
            })

        case &apos;Rejected&apos;:
            return promise2 = new Promise(function (resolve, reject) {
                setTimeout(function () {
                    thenDeal(onRejected, value, resolve, reject, promise2)
                })
            })
    }
}

function thenDeal(fn, value, resolve, reject, promise) {
    try {
        var x= fn(value);
        promiseResovle(promise, x, resolve, reject);
    } catch (e) {
        reject(e)
    }
}

function promiseResovle(promise, x, resolve, reject) {
    var then;
    var thenCalled = false;

    if (x === promise) {
        return reject(new TypeError(&apos;The promise has been circular used&apos;))
    }

    if (x instanceof Promise) {
        var status = x.__getStatus();
        if (status === &apos;Pending&apos;) {
            x.then(function(value) {
                promiseResovle(promise, value, resolve, reject)
            }, reject)
        } else {
            x.then(resolve, reject)
        }

        return ;
    }

    function resolvePromise(y) {
        if(thenCalled) return;
        thenCalled = true;
        promiseResolve(promise, y, resolve, reject)
    }

    function rejectPromise(r) {
        if (thenCalled) return;
        thenCalled = true;
        reject(r)
    }

    if(x !== null &amp;&amp; (typeof x === &apos;Object&apos; || typeof x === &apos;function&apos;)) {
        try {
            then = x.then;
            if (typeof then === &apos;function&apos;) {
                then.call(x, resolvePromise, rejectPromise)
            } else {
                resolve(x)
            }
        } catch (e) {
            reject(e)
        }
    } else {
        resolve(x)
    }
}

Promise.prototype.catch = function (onRejected) {
    return this.then(null, onRejected)
}

module.exports = Promise;
</code></pre><blockquote>
<p>参考文献:<br><a href="https://promisesaplus.com/" target="_blank" rel="external">Promise/A+规范英文原文</a><br><a href="http://malcolmyu.github.io/malnote/2015/06/12/Promises-A-Plus/" target="_blank" rel="external">Promise/A+规范中文翻译</a><br><a href="https://github.com/xieranmaya/blog/issues/3" target="_blank" rel="external">剖析Promise内部结构</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      Promise是js的一个异步流程控制标准，之前对async和promise的使用做了一个简单的对比，这次根据Promise/A+规范实现一个简单的Promise，以便对Promise有更深的了解
    
    </summary>
    
      <category term="Javascript" scheme="https://shadowwood.me/categories/Javascript/"/>
    
    
      <category term="javascript" scheme="https://shadowwood.me/tags/javascript/"/>
    
      <category term="node.js" scheme="https://shadowwood.me/tags/node-js/"/>
    
      <category term="Promise" scheme="https://shadowwood.me/tags/Promise/"/>
    
  </entry>
  
  <entry>
    <title>浅谈js异步流程框架async与Promise的区别</title>
    <link href="https://shadowwood.me/2016/04/25/2016-04-25-deference-between-async-and-promise/"/>
    <id>https://shadowwood.me/2016/04/25/2016-04-25-deference-between-async-and-promise/</id>
    <published>2016-04-25T08:02:00.000Z</published>
    <updated>2017-02-21T15:53:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在node.js中执行异步操作时，操作的结果并不是通过返回函数来反馈，而是通过将结果传入回调函数，由回调函数来处理运行结果。<br>如果在一个程序之中，我们需要多数的异步I/O操作，那么我们的回调结构将会是一层套一层不断的嵌套下去形成”callback hell(回调地狱)”。<br>虽然我们也可以通过声明函数的方法来简化回调结构并避免callback hell的产生，但是如果遇到一些比较复杂的依赖关系的话，可能依然会有一些问题。<br>最近接触到node.js两个不同的异步模块async和Promise，给大家做一下对比和分享。<br><a id="more"></a></p>
<h3 id="async-和-Promise简介"><a href="#async-和-Promise简介" class="headerlink" title="async 和 Promise简介"></a>async 和 Promise简介</h3><p>async(<a href="https://github.com/caolan/async" target="_blank" rel="external">github</a>)是一个包含了许多js异步操作方法的node.js模块，其中共有70个函数，包括一些与数组类似的方法(map, each, filter, reduce…)，和一些异步流程方法(series, parallel, waterfall, …)。<br>这些方法都必须要求在node环境在才能运行实现，并且运行结果都是传递到一个回调函数里，一般都是两个参数，一个参数是错误异常error，另一个是操作结果。</p>
<p>Promise应该算是一个异步操作标准。<br>Promise被定义为一个对象，来传递异步操作的消息，它代表了某个未来才会知道的结果的事件，并且这个事件提供统一的API，可供进一步的处理；Promise对象有两个特点：</p>
<ul>
<li>对象的状态不受外界影响；</li>
<li>对象的状态一旦改变便不会再变，并且任何时候都可以得到这个结果。</li>
</ul>
<p>对于Promise的实现有很多js库，并且对于这些js库也有一套评价标准<a href="https://promisesaplus.com/" target="_blank" rel="external">Promise/A+</a>。<br>本文介绍的Promise使用的bluebird(<a href="http://bluebirdjs.com/docs/getting-started.html" target="_blank" rel="external">官方文档</a>)这个库。</p>
<h3 id="一个简单的异步实现"><a href="#一个简单的异步实现" class="headerlink" title="一个简单的异步实现"></a>一个简单的异步实现</h3><p>我们来进行一个简单的操作：使用fs.readFile从read.txt里面读取文件内容，然后将读取的内容用writeFile写入write.txt。</p>
<h4 id="不用async和Promise"><a href="#不用async和Promise" class="headerlink" title="不用async和Promise"></a>不用async和Promise</h4><pre><code>var fs = require(&apos;fs&apos;);
fs.readFile(&apos;./read.txt&apos;, (err, data) =&gt; {
    fs.writeFile(&apos;./write.txt&apos;, data, (err) =&gt; {
        console.log(&quot;end&quot;);
    })
})
</code></pre><h4 id="async"><a href="#async" class="headerlink" title="async"></a>async</h4><pre><code>var async = require(&apos;async&apos;);
var fs = require(&apos;fs&apos;);
async.waterfall([
  callback =&gt; fs.readFile(&apos;./read.txt&apos;,
    (err, data) =&gt; {
      callback(null, data)
  }),
  (data, callback) =&gt; fs.writeFile(&apos;./write.txt&apos;,
    data,
    (err) =&gt; {
      callback(err)
    })
], (err, r) =&gt; console.log(&quot;end&quot;));
</code></pre><h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><pre><code>var Promise = require(&apos;bluebird&apos;);
var fs = require(&apos;fs&apos;);
var promise = new Promise((resolve, reject) =&gt; {
  fs.readFile(&apos;./read.txt&apos;, (err, data) =&gt; {
    if(err) reject(err);
    resolve(data)
  })
});

promise.then((data) =&gt; {
  fs.writeFile(&apos;./write.txt&apos;, data, (err) =&gt; {
    console.log(&quot;end&quot;)
  })
});
</code></pre><p> 咋一看觉得不用async或者Promise好像结构还简单一些，那么如果我们是这样一个操作流程:</p>
<pre><code>function a(data1, data2 =&gt; {
    function b(data2, data3 =&gt; {
        function c(data3, data4 =&gt; {
            function d(data4, data5 =&gt; {
                ....
            })
        })
    })
})
</code></pre><p>也就是说当我们遇到有多层回调的时候，这个结构就相当难看了，当时如果用async或者Promise的话,可以将多层回调变成同步的样式来进行操作</p>
<pre><code>//async
async.waterfall([
    cb =&gt; cb(err, data1),
    cb =&gt; cb(err, data1, data2),
    cb =&gt; cb(err, data2, data3),
    cb =&gt; cb(err, data3, data4),
    ...
], (err, r) =&gt; console.log(&quot;end&quot;))

// Promise
var promise = new Promise((resolve, reject) =&gt; {
    resolve(data1)
})
promise
.then(data1 =&gt; return data2)
.then(data2 =&gt; return data3)
.then(data3 =&gt; return data4)
...
</code></pre><h3 id="简单对比"><a href="#简单对比" class="headerlink" title="简单对比"></a>简单对比</h3><p>async的主要实现方式挺容易理解的，它本质是提供了一系列的工具函数，来帮助解决多层回调的问题，最常见的方式就是将多个异步操作集合到数组里，然后根据这些异步操作的相互间的关系来选择它提供的方法进行实现。</p>
<p>而Promise是将异步操作封装为对象，异步的结果输出到对象的.then()方法里，然后.then()方法的返回值又是一个Promise对象并且在.then()方法里return的值会传递到下一个.then()，即链式法则。</p>
<p>在async中我们如果在处理上一个异步回调的结果的时候，又需要用一个异步回调，并且还需要将这个异步回调的结果传递给下一个异步回调的话，我们只需要将结果放在callback()里就行了。</p>
<p>但是在Promise里，我们如果在.then()方法里还需要有异步操作，并且需要将这个异步操作的值传递出去，以便链式方法能够获取到这个参数该怎么办呢？</p>
<p>这里我们在稍微改一下上一个例子，我们先向write.txt里面写入一个’test’字符串，操作成功后读取write.txt的内容并打印，然后再读取read.txt里面的内容，然后将之前内容覆盖并写入write.txt里面：</p>
<pre><code>var Promise = require(&apos;bluebird&apos;);
var fs = require(&apos;fs&apos;);
var readFileAsync = Promise.promisify(fs.readFile);
var writeFileAsync = Promise.promisify(fs.writeFile);

writeFileAsync(&apos;./write.txt&apos;, &apos;test\n&apos;)
  .then(() =&gt; readFileAsync(&apos;./write.txt&apos;))
  .then((data) =&gt; {
    console.log(data.toString());
    return readFileAsync(&apos;./read.txt&apos;)
  })
  .then(data =&gt; writeFileAsync(&apos;./write.txt&apos;, data))
  .then(() =&gt; readFileAsync(&apos;./write.txt&apos;))
  .then(data =&gt; console.log(data.toString()));
</code></pre><p>首先我们将fs.readFile和fs.writeFile通过bluebird的promisify方法做Promise封装，命名为readFileAsync和writeFileAsync。<br>这样它们的返回值就变成了Promise对象，并且它们的本来应该返回到回调函数里的结果返回到了.then()方法里。<br>因为我们只要在.then()方法里return Promise对象，.then()的值就是我们内层返回的Promise对象，故我们又可以继续用.then()来使用数据并且操作，依次类推。</p>
<p>所以用Promise的进行多层异步回调的简化的一个基本思路就是，我们需要将这些异步回调想办法返回Promise对象，做Promise封装也好，重新构建一个Promise对象返回也好，都大同小异。</p>
<p>而async的对多层回调简化的思路就是只需要将值传递到callback里，就能被外层的函数来获取到结果。</p>
]]></content>
    
    <summary type="html">
    
      异步流程的实现是node.js一个重要的模块，最近接触到async和Promise这两个node.js的异步模块，给大家做一下对比和简单的分享。
    
    </summary>
    
      <category term="Javascript" scheme="https://shadowwood.me/categories/Javascript/"/>
    
    
      <category term="javascript" scheme="https://shadowwood.me/tags/javascript/"/>
    
      <category term="node.js" scheme="https://shadowwood.me/tags/node-js/"/>
    
      <category term="async" scheme="https://shadowwood.me/tags/async/"/>
    
      <category term="Promise" scheme="https://shadowwood.me/tags/Promise/"/>
    
      <category term="异步" scheme="https://shadowwood.me/tags/%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>js实现图片异步上传</title>
    <link href="https://shadowwood.me/2016/04/22/2016-04-22-js-upload-picture/"/>
    <id>https://shadowwood.me/2016/04/22/2016-04-22-js-upload-picture/</id>
    <published>2016-04-22T05:23:00.000Z</published>
    <updated>2017-02-21T15:53:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近在学习node.js的express框架，其中包含了一个用户系统。<br>之前在做用户系统的时候对用户信息的编辑更新都是用的同步的方式来进行表单提交，这一次兴趣使然想用异步的方式来实现信息编辑的表单提交，用jquery框架的ajax方法的对普通的文本信息都能很好的实现。<br>但是在图片的异步请求提交的时候遇到了一些问题。<br>因为jquery框架的ajax方法本身对二进制数据的表单提交没有很好的支持，网上的很多推荐实现方式都说用额外的插件来实现，但是由于‘’不可描述“的原因，当时下载这些插件来使用有些不方便，所以便一直探索不用其他插件的情况下，用jquery的ajax或者原生的js来实现.<br><a id="more"></a></p>
<h3 id="使用jquery的ajax方法实现"><a href="#使用jquery的ajax方法实现" class="headerlink" title="使用jquery的ajax方法实现"></a>使用jquery的ajax方法实现</h3><h4 id="前端表单"><a href="#前端表单" class="headerlink" title="前端表单"></a>前端表单</h4><pre><code>&lt;form id=&quot;avatar_form&quot; enctype=&quot;multipart/form-data&quot;&gt;
    &lt;input type=&quot;file&quot; name=&quot;avatar&quot;&gt;
&lt;/form&gt;
</code></pre><h4 id="js代码"><a href="#js代码" class="headerlink" title="js代码"></a>js代码</h4><pre><code>function uploadAvatar () {
    var data = new FormData();
    var files = $(&quot;input[name=&apos;avatar&apos;]&quot;)[0].files;
    if (files) {
        data.append(&quot;file&quot;, files[0])
    } else {
        alert(&quot;please choose a picture&quot;)
    }

    $.ajax({
        type: &apos;put&apos;,
        dataType: &apos;json&apos;,
        url: &quot;/user/change_avatar&quot;
        data: data,
        contentType: false,
        processData: false,
        success: function (data) {
            alert(&apos;success&apos;);
        }
    })
}
</code></pre><p>使用jquery的ajax方法实现的主要思想是<strong>我们重新构建一个表单，用jquery读取html中表单的图片信息，然后向新表单之中加入文件，并且不让ajax来自动处理我们的表单数据，直接将原始表单数据提交</strong></p>
<p>相信大家也注意到了，在ajax的设置参数里，我们多了几个参数的设置：</p>
<ul>
<li>contentType</li>
<li>processDate</li>
</ul>
<p>根据jquery ajax的官方文档<a href="http://api.jquery.com/jquery.ajax/" target="_blank" rel="external">http://api.jquery.com/jquery.ajax/</a>，这几个参数的设置主要是一下用途：</p>
<ol>
<li><p>contentType (值类型:Boolean or String, 默认值:’application/x-www-form-urlencoded; charset=UTF-8’)<br>这个值用来设置HTTP请求的content-type头信息，默认是’application/x-www-form-urlencoded; charset=UTF-8’。<br>在jQuery1.6版本之后，这个值可以设置为false，用来告诉jQuery不要设置请求的content-type头信息。<br>由于我们这里需要使用原始的表单，不需要jQuery帮我们设置content-type信息，FormData对象会根据表单的值来设置，故而将这个值设置为false。</p>
</li>
<li><p>processData (值类型:Boolean, 默认值: true)<br>这个值的设定是整个过程最重要的一部分，因为当这个值为true的时候，ajax会将data里的值处理成contentType里我们设置的类型，默认是”application/x-www-form-urlencoded”。<br>当这个值为false的时候，ajax就不会对data里的值进行处理，这正是我们所需要的</p>
</li>
</ol>
<p>其实整个过程最重要的部分还是FormData。<br>FormData是XMLHttpRequest Level 2添加了一个新的接口.利用FormData对象,我们可以通过JavaScript用一些键值对来模拟一系列表单控件,<br>构造函数</p>
<pre><code>new FormData(optional HTMLFormElement form)
</code></pre><p>form 参数是一个可选的HTML表单元素,可以包含任何形式的表单控件,包括文件输入框。</p>
<p>FormData对象还可以使用append方法添加键值对，如</p>
<pre><code>var form = new FormData();

form.append(&quot;name&quot;, &quot;testName&quot;);
form.append(&quot;num&quot;, 123456); // 数字123456被立即转换成字符串&quot;123456&quot;

// fileInputElement中已经包含了用户所选择的文件
form.append(&quot;file&quot;, fileInputElement.files[0]);
</code></pre><p>使用FormData最主要的优势便是我们可以用它构造表单来传输二进制文件，故而是异步上传图片的较好选择。<br>在浏览器的支持方面</p>
<table>
<thead>
<tr>
<th>Chrome</th>
<th>FireFox(Gecko)</th>
<th>IE</th>
<th>Opera</th>
<th>Safari</th>
</tr>
</thead>
<tbody>
<tr>
<td>7+</td>
<td>4.0(2.0)</td>
<td>10+</td>
<td>12+</td>
<td>5+</td>
</tr>
</tbody>
</table>
<h3 id="XMLRequest实现"><a href="#XMLRequest实现" class="headerlink" title="XMLRequest实现"></a>XMLRequest实现</h3><p>当然除了ajax异步的方式，也可以是用XMLRequest的方式实现异步请求，如果是要传输二进制文件的话，一样是可以用到FormData对象来构造表单，然后用XMLRequest异步请求的方式将FormData对象当作表单提交即可。</p>
<pre><code>var formEle = document.getElementById(&quot;avatar_form&quot;);
var form = new FormData(formEle);

var xReq = new XMLHttpRequest();
xReq.open(&quot;PUT&quot;, &quot;/user/change_avatar&quot;, true);
xReq.onload = function(oEvent) {
    if (oReq.status == 200) {
        alert(&quot;success&quot;);
    } else {
         alert(&quot;failed&quot;)
    }
};

xReq.send(form);
</code></pre>]]></content>
    
    <summary type="html">
    
      最近在做express练习项目的时候需要解决一个图片异步上传的问题，简单分享下几种的实现方式
    
    </summary>
    
      <category term="Javascript" scheme="https://shadowwood.me/categories/Javascript/"/>
    
    
      <category term="javascript" scheme="https://shadowwood.me/tags/javascript/"/>
    
      <category term="异步" scheme="https://shadowwood.me/tags/%E5%BC%82%E6%AD%A5/"/>
    
      <category term="图片上传" scheme="https://shadowwood.me/tags/%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0/"/>
    
  </entry>
  
  <entry>
    <title>浅析javascript的继承方式</title>
    <link href="https://shadowwood.me/2016/04/20/2016-04-20-javascript-inherit/"/>
    <id>https://shadowwood.me/2016/04/20/2016-04-20-javascript-inherit/</id>
    <published>2016-04-20T09:08:30.000Z</published>
    <updated>2017-02-21T15:53:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>继承是面向对象语言的一个最为重要的概念。许多面向对象语言都支持两周继承方式：接口继承和实现继承。<br>接口继承只继承方法签名，实现继承则继承实际的方法。<br>然而，函数并没有签名，所以在ES中无法实现接口继承，只有实现继承，并且实现方式主要是依靠原型链来实现。<br><a id="more"></a></p>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>原型链的基本思想是<strong>利用原型让一个引用类型继承另一个引用类型的属性和方法</strong>，其基本模式如下：</p>
<pre><code>function SuperType () {
    this.property = true;
}

SuperType.prototype.getProperty = function () {
    console.log(this.property)
}

function SubType () {
    this.subProperty = false;
}

SubType.prototype = new SuperType();
SubType.prototype.getSubProperty = function () {
    console.log(this.subProperty)
}

var instance = new SubType();
console.log(instance.property); // true
console.log(instance.subProperty); // false
instance.getProperty(); // true
instance.getSubProperty(); // false
</code></pre><p>在以上代码中，SubType继承了SuperType的属性和方法，实现的方法是通过将SuperType的实例赋于SubType.prototype，即重写SubType的原型对象。</p>
<p>我们可以通过instanceof操作符或者isPrototypeOf()方法来确定原型和实例之间的关系，对于以上代码：</p>
<pre><code>console.log(instance instanceof Object); // true
console.log(instance instanceof SuperType); // true
console.log(instance instanceof SubType); // true

console.log(Object.prototype.isPrototypeOf(instance)); // true
console.log(SuperType.prototype.isPrototypeOf(instance)); // true
console.log(SubType.prototype.isPrototypeOf(instance)); //true
</code></pre><p>原型链继承是最常见的继承方式，但是也存在一些问题。最主要的问题来自包含引用类型的原型，例如:</p>
<pre><code>function SuperType () {
    this.arr = [1, 2, 3, 4]
}

function SubType () {}

SubType.prototype = new SuperType();

var instance1 = new SubType();
instance1.arr.push(4);
console.log(instance1.arr); // 1, 2, 3, 4

var instance2 = new SubType();
console.log(instance2.arr); // 1, 2, 3, 4
</code></pre><p>在这个例子中，我们想对instance1的arr数组添加元素4，但是却影响到了instance2。<br>这是因为arr这个属性是来自于SuperType的同一个实例，也就是说instance1.arr和instance2.arr指向的是同一个数组，当对instance1.arr操作时，就会一样影响到instance2.arr。</p>
<p>原型链的第二个问题是：当我们创建子类型的实例时，没有办法在不影响所有超类型的对象实例的情况下向继承于超类型的构造函数中传递参数。</p>
<p>基于这两个主要问题，所以在实际运用中很少单独用原型链的方式来实现继承。</p>
<h3 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h3><p>借用构造函数的基本思想是<strong>在子类型构造函数的内部调用超类型构造函数</strong>，如下所示:</p>
<pre><code>function SuperType (name) {
    this.arr = [1, 2, 3];
    this.name = name;
}

function SubType () {
    // 继承 SuperType
    SuperType.call(this, &apos;subtype&apos;)
}

var instance0 = new SuperType(&apos;supertype&apos;);
console.log(instance0.name); // &apos;supertype&apos;

var instance1 = new SubType();
instance1.arr.push(4);
console.log(instance1.arr); // 1, 2, 3, 4
console.log(instance1.name); // &apos;subtype&apos;
console.log(instance0.name); // &apos;supertype&apos;

var instance2 = new SubType();
console.log(instance2.arr); // 1, 2, 3
console.log(instance2.name); // &apos;subtype&apos;
</code></pre><p>上例中，通过在SubType中使用SuperType.apply()方法来操作SubType的作用域this，使得子类型定义了与超类型相同的属性，从而实现了SubType继承了SuperType的属性，并且我们还能在不影响SuperType所有对象实例的情况下，通过传递参数来定义继承于SuperType的属性。</p>
<p>借用构造函数的继承方式解决了原型链中存在的两个主要问题，即：</p>
<ul>
<li><strong>包含引用类型引起的问题</strong></li>
<li><strong>无法在不影响超类型的所有实例对象的情况下向子类型构造中向超类型构造函数传递参数</strong></li>
</ul>
<p>但是借用构造函数由于是用在内部调用构造函数来实现继承的，所以它的方法都是在构造函数里定义，那么就无法像原型链一样使用<strong>Object.prototype.attr = function</strong> 的定义方法的方式来实现函数的复用，所以在实际运用中也很少单独使用借用构造函数的方式来实现继承</p>
<h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>结合原型链和借用构造函数的继承方式，取长补短便产生了组合继承，即<strong>使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承</strong>，如下所示:</p>
<pre><code>function SuperType (name) {
  this.name = name;
  this.arr = [1, 2, 3];
}

function getName () {
  console.log(this.name)
}

SuperType.prototype.getName = getName;

function SubType (name, age) {
  // 借用构造函数，实现继承实例属性
  SuperType.call(this, name);
  this.age = age;
}

// 原型继承，实现对方法的继承
SubType.prototype = new SuperType();
SubType.prototype.constructor = SubType;
SubType.prototype.getAge = function () {
  console.log(this.age)
};

var instance1 = new SubType(&apos;in1&apos;, 10);
instance1.arr.push(4);
console.log(instance1.arr); // 1, 2, 3, 4
instance1.getName(); // &apos;in1&apos;
instance1.getAge(); // 10

var instance2 = new SubType(&apos;in2&apos;, 20);
console.log(instance2.arr); // 1, 2, 3
instance2.getName(); // &apos;in2&apos;
instance2.getAge(); //20
</code></pre><p>在本例中，SubType既使用了原型链的继承方式继承了SuperType的getName方法，并且可以用函数复用的方式来定义getName方法又通过借用构造函数的继承方式继承name和arr属性，让SubType的两个不同实例分别拥有自己的属性。</p>
<p>组合继承避免了原型链和借用构造函数的缺陷，因而在实际应用中是JS中最常见的继承模式。</p>
<h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><p>2006年，Douglas Crockford提出原型式继承的方式，即<strong>借助原型可以基于已有的对象创造新对象，同时还不必自己因此创建自定义类型</strong>，他给出了如下代码:</p>
<pre><code>function object (o) {
    function F () { }
    F.prototype = o;
    return new F()
}
</code></pre><p>在object()函数内部定义了一个临时的构造函数F，将传入的实例对象o作为F的原型，然后返回F的一个新实例。</p>
<p>在ES5中，这个方法被规范化，并且用Object.create()来实现，即我们可以通过Object.create()来实现与构造函数实现原型链一样的效果：</p>
<pre><code>var whiteCar = {
    color: &apos;white&apos;,
    users: [&apos;Tom&apos;, &apos;Jim&apos;]
}

var blackCar = Object.create(whiteCar)
blackCar.color = &apos;black&apos;
blackCar.users.push(&apos;Black&apos;)

console.log(whiteCar.users) // &apos;Tom&apos;, &apos;Jim&apos;, &apos;Black&apos;
</code></pre><p>如上例所示原型式继承和原型链一样存在因包含引用类型引起的问题，因为它的实现方式本质和之前提到的原型链一样，只不过它没有采用构造函数来实现，而是直接操作对象来实现继承。</p>
<h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><p>寄生式继承是基于原型式继承思想的一种实现方法，即<strong>创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真的是它做了所有的工作一样返回对象</strong>，如下所示：</p>
<pre><code>function createCar (original) {
    var clone = Object.create(original);
    clone.getColor = function () {
        console.log(this.color)
    }
    return clone;
}

var whiteCar = {
    color: &apos;white&apos;,
    users: [&apos;Tim&apos;, &apos;Tom&apos;]
}

var blackCar = createAnother(whiteCar);
blackCar.color = &apos;black&apos;;
blackCar.getColor() // &apos;black&apos;
</code></pre><p>寄生式继承相对于原型式继承只是将增强新对象（添加属性和方法）在一个函数中实现，其中，不一定要使用Object.create()来创造新对象，任何可以返回新对象的方法都可以。</p>
<h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3><p>用寄生式继承将组合式继承改进，即<strong>使用寄生式继承来继承超类型的原型，然后再将结果指定的子类型的原型</strong>，就形成了寄生组合式继承的方法如下所示：</p>
<pre><code>// 寄生式组合式继承核心
function inheritPrototype (subType, superType) {
    var prototype = Object.create(superType.prototype);
    // 为创建的副本重写constructor属性，弥补因重写原型而失去默认的construct属性
    prototype.constructor = subType;
    SubType.prototype = prototype;
}

function SuperType (name) {
    this.name = name;
    this.arr = [1, 2, 3]
}

SuperType.prototype.getName = function () {
    console.log(this.name)
}

function SubType (name, age) {
    SuperType.call(this, name)
    this.age = age
}

inheritPrototype(SubType, SuperType);

SubType.prototype.getAge = function () {
    console.log(this.age);
}
</code></pre><p>其中inheritPrototype函数是整个寄生组合式继承过程的核心，即通过类似寄生式继承的方式实现Subtype对SuperType的原型继承，然后在子类型实例化的时候，又因为内部构造函数实现借用构造函数方式来继承了SuperType的属性。</p>
<p>这个例子的高效率体现在它只调用了一次 SuperType构造函数，而在组合式继承的例子里面调用了两次(SuperType.call(), new SuperType)，并且因此避免了在SubType.prototype上面创建不必要的，多余的属性。与此同时还保证了原型链的不变，从而能正常使用 instanceof 和 isPrototypeOf方法。</p>
<p> 故寄生组合式继承是目前最理想的继承方法。</p>
<hr>
<p>参考资料：</p>
<ul>
<li>《JavaScript 高级程序设计(第三版)》(Nicholas C.Zakas著，李松峰 曹力译)</li>
</ul>
]]></content>
    
    <summary type="html">
    
      本文将列举出javascript的6种继承方式及举例一些简单的应用场景
    
    </summary>
    
      <category term="Javascript" scheme="https://shadowwood.me/categories/Javascript/"/>
    
    
      <category term="javascript" scheme="https://shadowwood.me/tags/javascript/"/>
    
      <category term="继承" scheme="https://shadowwood.me/tags/%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>node.js的安装与npm的使用</title>
    <link href="https://shadowwood.me/2016/04/19/2016-04-19-npm-setup-and-use/"/>
    <id>https://shadowwood.me/2016/04/19/2016-04-19-npm-setup-and-use/</id>
    <published>2016-04-19T07:35:30.000Z</published>
    <updated>2017-02-23T16:39:04.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是npm"><a href="#什么是npm" class="headerlink" title="什么是npm"></a>什么是npm</h3><p>npm, Node Package Manager, 是随同node.js一起安装的包管理工具。该管理工具可用于从第三方网站上下载node.js包，常用于：</p>
<ul>
<li>允许开发者从npm服务器下载别人编写的第三方包到本地使用。</li>
<li>允许开发者从npm服务器下载并安装别人编写的命令行程序到本地使用。</li>
<li>允许开发者将自己编写的包或命令行程序上传到npm服务器供别人使用。</li>
</ul>
<p>从而方便开发者的项目构建和解决node.js项目部署上的很多问题。<br><a id="more"></a></p>
<h3 id="node-js的安装"><a href="#node-js的安装" class="headerlink" title="node.js的安装"></a>node.js的安装</h3><p>node.js历史包版本下载地址 <a href="https://nodejs.org/dist/" target="_blank" rel="external">https://nodejs.org/dist/</a></p>
<h4 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h4><ol>
<li>下载安装包安装:</li>
</ol>
<p>在历史包版本里面找到最新版本的.msi文件，下载并执行安装；<br><br>在cmd里面输入path查看是否有npm的环境变量()，如果没有则需要将手动配置node.js和npm的环境变量，即将其安装路径添加到环境变量path之中就行（一般来说安装包里有选项会默认帮用户配置的）</p>
<ol>
<li>下载二进制文件安装:</li>
</ol>
<p>在历史包版本里找到最新版本的.exe文件，下载并运行即可;</p>
<h4 id="linux-ubuntu"><a href="#linux-ubuntu" class="headerlink" title="linux ubuntu"></a>linux ubuntu</h4><ol>
<li>从github上获取源码安装:</li>
</ol>
<p>在 Github 上获取 Node.js 源码：</p>
<pre><code>$ sudo git clone https://github.com/nodejs/node.git
</code></pre><p>修改目录权限：</p>
<pre><code>$ sudo chmod 755 -R node
</code></pre><p>使用 ./configure 创建编译文件，并按照：</p>
<pre><code>$ cd node
$ sudo ./configure
$ sudo make
$ sudo make install
</code></pre><p>查看 node 版本：</p>
<pre><code>$ node --version
</code></pre><ol>
<li>使用apt-get进行安装：</li>
</ol>
<p>直接运行以下命令即可：</p>
<pre><code>sudo apt-get install nodejs
sudo apt-get install npm
</code></pre><h4 id="Mac-Os"><a href="#Mac-Os" class="headerlink" title="Mac Os"></a>Mac Os</h4><p>使用homebrew进行安装:</p>
<pre><code>brew install node
</code></pre><h3 id="npm常见命令与使用"><a href="#npm常见命令与使用" class="headerlink" title="npm常见命令与使用"></a>npm常见命令与使用</h3><h4 id="安装node-js的包"><a href="#安装node-js的包" class="headerlink" title="安装node.js的包"></a>安装node.js的包</h4><ol>
<li><strong>npm install &lt;name&gt;</strong>  安装nodejs的依赖包</li>
<li><strong>npm install &lt;name&gt; -g</strong>  将包安装到全局环境中<br><br>但是代码中，直接通过require()的方式是没有办法调用全局安装的包的。全局的安装是供命令行使用的</li>
<li><strong>npm install &lt;name&gt; –save</strong>  安装的同时，将信息写入package.json中<br><br>项目路径中如果有package.json文件时，直接使用npm install方法就可以根据dependencies配置安装所有的依赖包</li>
<li><strong>npm init</strong>  引导你创建一个package.json文件，包括名称、版本、作者这些信息等</li>
<li><strong>npm remove &lt;name&gt;</strong> 移除包</li>
<li><strong>npm update &lt;name&gt;</strong> 更新包</li>
<li><strong>npm ls</strong> 列出当前安装的了所有包</li>
<li><strong>npm root</strong> 查看当前包的安装路径<br>9 <strong>npm root -g</strong>  查看全局的包的安装路径</li>
<li><strong>npm help</strong>  帮助，如果要单独查看install命令的帮助，可以使用的<strong>npm help install</strong></li>
<li><strong>npm config set registry &lt;源地址&gt;</strong> npm换源命令，&lt;源地址&gt;的格式须以’<a href="http://&#39;或&#39;https://&#39;开头" target="_blank" rel="external">http://&#39;或&#39;https://&#39;开头</a></li>
<li><strong>npm view &lt;name&gt; versions</strong> 查看npm包的历史版本</li>
</ol>
]]></content>
    
    <summary type="html">
    
      本文将介绍各平台下npm的安装以及npm常见命令的使用
    
    </summary>
    
      <category term="Nodejs" scheme="https://shadowwood.me/categories/Nodejs/"/>
    
    
      <category term="nodejs" scheme="https://shadowwood.me/tags/nodejs/"/>
    
      <category term="npm" scheme="https://shadowwood.me/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>PPPoE服务器添加Radius支持</title>
    <link href="https://shadowwood.me/2015/05/19/2015-05-19-build-PPPoE-and-Radious-On-Ubuntu/"/>
    <id>https://shadowwood.me/2015/05/19/2015-05-19-build-PPPoE-and-Radious-On-Ubuntu/</id>
    <published>2015-05-19T00:46:00.000Z</published>
    <updated>2017-02-21T15:53:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本片文章紧接之前的PPPoE服务器配置和Radius服务器配置，如果还没进行过这两步的同志请移步这里：</p>
<ul>
<li><a href="/linux/2015/04/18/build-PPPoE-On-Ubuntu.html">ubuntu上搭建PPPoE认证服务器</a></li>
<li><a href="/linux/2015/04/29/build-FreeRadius-On-Ubuntu.html">ubuntu上安装和配置FreeRadius</a></li>
</ul>
<a id="more"></a>
<h3 id="PPPoE服务器配置"><a href="#PPPoE服务器配置" class="headerlink" title="PPPoE服务器配置"></a>PPPoE服务器配置</h3><p>我们只需要在之前的PPPoE服务器上修改和添加一些东西即可。</p>
<p>首先，确认 /etc/ppp/   路径下是否有radius文件夹，若没有，则安装radiusclient1，即：</p>
<pre><code>sudo apt-get install radiusclient1
</code></pre><p>然后在 /etc/ppp/路径下新建一个radius文件夹，将/etc/radiusclient/ 文件夹下的所有文件拷贝到 /etc/ppp/radius/ 目录下(若已有radius文件夹，请忽略此步骤)</p>
<p>之后，修改 /etc/ppp/radius/radiusclient.conf 文件，修改以下两项：</p>
<pre><code>authserver     10.37.129.5:1812
acctserver     10.37.129.5:1813
</code></pre><p>其中  10.37.129.5  为笔者配置的Freeradius服务器ip地址，读者需根据自己的Freeradius服务器地址来配置该项。</p>
<p>修改 /etc/ppp/pppoe-server-options 文件：</p>
<pre><code>auth
require-chap
default-mru
default-asyncmap
lcp-echo-interval 60
lcp-echo-failure 5
ms-dns 192.168.0.1
ms-dns 10.132.129.1
noipdefault
noipx
nodefaultroute
noproxyarp
noktune
netmask 255.255.255.0
logfile /var/log/pppd.log
plugin radius.so  #配合radius 使用
plugin radattr.so
radius-config-file /etc/ppp/radius/radiusclient.conf
</code></pre><p>注意</p>
<ul>
<li>ms-dns为 DNS 服务器ip地址，请读者根据自己实际情况配置；</li>
<li>radius.so 和 radattr.so为radius支持文件，请读者仔细检查 /etc/ppp/ 路径下是否有这两个文件，若没有就去百度或者谷歌下载吧＝。＝；</li>
</ul>
<p>接着修改/etc/ppp/radius/server 文件，添加freeradius服务器ip地址和共享密钥(需和freeradius服务器配置一致)：</p>
<pre><code>10.37.129.5  testing123
</code></pre><p>其中 10.37.129.5 为笔者的Freeradius服务器地址，请读者根据自己的实际情况配置；testing123为readius客户端与freeradius服务器的共享密钥，需要与之后的freeradius服务器配置一致。</p>
<h3 id="Freeradius服务器配置"><a href="#Freeradius服务器配置" class="headerlink" title="Freeradius服务器配置"></a>Freeradius服务器配置</h3><p>接着之前Freeradius服务器的配置。</p>
<p>修改 /etc/freeradius/client.conf 文件，添加PPPoE服务器的信息：</p>
<pre><code>client 10.37.129.4 {
ipaddr = 10.37.129.4
secret = testing123
require_message_authenticator = no
}
</code></pre><p>其中10.37.129.4为PPPoE服务器的ip地址，请读者根据自己的实际情况配置。</p>
<h3 id="启动服务器"><a href="#启动服务器" class="headerlink" title="启动服务器"></a>启动服务器</h3><p>启动freeradius服务器</p>
<pre><code>freeradius -X
</code></pre><p>启动PPPoE服务器</p>
<pre><code>sudo pppoe-server -I eth1 -L 11.11.11.1 -R 11.11.11.10 -N 20
</code></pre><hr>
<p>参考博客</p>
<ul>
<li><a href="http://blog.chinaunix.net/uid-21651676-id-3030200.html" target="_blank" rel="external">http://blog.chinaunix.net/uid-21651676-id-3030200.html</a></li>
<li><a href="http://blog.atime.me/note/freeradius_daloradius_install_config_on_ubuntu.html" target="_blank" rel="external">http://blog.atime.me/note/freeradius_daloradius_install_config_on_ubuntu.html</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      本文章将分享如何将PPPoE服务器与Radius服务器进行对接，以及在配置过程中遇到的一些问题解决办法。
    
    </summary>
    
      <category term="Linux" scheme="https://shadowwood.me/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://shadowwood.me/tags/Linux/"/>
    
      <category term="PPPoE" scheme="https://shadowwood.me/tags/PPPoE/"/>
    
      <category term="Radius" scheme="https://shadowwood.me/tags/Radius/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu上安装和配置FreeRadius</title>
    <link href="https://shadowwood.me/2015/04/29/2015-04-29-build-FreeRadius-On-Ubuntu/"/>
    <id>https://shadowwood.me/2015/04/29/2015-04-29-build-FreeRadius-On-Ubuntu/</id>
    <published>2015-04-29T07:09:00.000Z</published>
    <updated>2017-02-21T15:53:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前面笔者分享了在ubuntu上搭建PPPoE服务器的步骤和一些问题及解决办法，但是这学期的综合课程设计内容是要求搭建和配置由radius协议实现认证和计费的PPPoE服务器，之前的东西只是第一步，本文接着分享如何在ubuntu上安装配置FreeRadius来实现基于radius协议的认证和计费。<br>关于radius的介绍可以看一下这里：</p>
<ul>
<li><a href="http://blog.csdn.net/liang13664759/article/details/1574367/" target="_blank" rel="external">http://blog.csdn.net/liang13664759/article/details/1574367/</a></li>
</ul>
<a id="more"></a>
<h3 id="系统配置及需要安装的软件"><a href="#系统配置及需要安装的软件" class="headerlink" title="系统配置及需要安装的软件"></a>系统配置及需要安装的软件</h3><ul>
<li>系统：ubuntu 14.04</li>
<li>安装软件：<ul>
<li>freeradius-mysql(自动安装freeradius本体)</li>
<li>mysql-server</li>
</ul>
</li>
</ul>
<p>安装命令：</p>
<pre><code>sudo apt-get install freeradius-mysql mysql-server
</code></pre><h3 id="进行FreeRadius基本配置"><a href="#进行FreeRadius基本配置" class="headerlink" title="进行FreeRadius基本配置"></a>进行FreeRadius基本配置</h3><p>修改 /etc/freeradius/clients.conf，这是FreeRadius的客户端配置文件，在这里我们要将我们之后要与服务器连接的客户端的信息写入配置文件，例如加入如下几行：</p>
<pre><code>client 192.168.0.2 {
  ipaddr = 192.168.0.2
  secret = testing123
  require_message_authenticator = 0
}
</code></pre><p>表示有一个 ip地址为192.168.0.2的客户端之后要接入Freeradius服务器，它与服务器的共享密钥为 testing123。<br>该配置文件一般已经配置好了一个本地测试的客户端，即ip地址为 localhost 的客户端。</p>
<p>修改 /etc/freeradius/radiusd.conf，这是FreeRadius的配置文件，取消下一行的注释来包含FreeRadius的 sql 配置文件：</p>
<pre><code>$INCLUDE  sql.conf
</code></pre><p>修改/etc/freeradius/sql.conf，这是FreeRadius与 mysql 数据库相关的配置文件，注意一下几行：</p>
<pre><code>server = &quot;localhost&quot;
login = &quot;root&quot;
password = &quot;123456&quot;
</code></pre><p>这里为mysql数据库的ip地址，用户名和密码，默认使用3306端口，当然也可以自己加一行 port=”端口号” 来根据自己的喜好配置。(这几行应该配置文件里有，不需要修改，如果没有就自己加上)</p>
<p>接着取消掉文件中下面一行，来让FreeRadius从数据库里面读取客户端的信息：</p>
<pre><code>readclients = yes
</code></pre><p>接着切换到 /etc/freeradius/sql/mysql，该文件下的众多sql脚本文件用于构建FreeRadius的数据库，首先在admin.sql里修改数据库名称，用户名和密码等内容(默认配置是radius, root, 123456，若之前数据不是默认配置，需对sql语句进行相关修改)，这些内容必须和/etc/freeradius/sql.conf的设置相同。</p>
<p>最后修改/etc/freeradius/sql/mysql/dialup.conf文件，取消掉以下几行的注释来提供在线人数统计功能：</p>
<pre><code>simul_verify_query  = &quot;SELECT radacctid, acctsessionid, username, \
                        nasipaddress, nasportid, framedipaddress, \
                        callingstationid, framedprotocol \
                        FROM ${acct_table1} \
                        WHERE username = &apos;%{SQL-User-Name}&apos; \
                        AND acctstoptime IS NULL&quot;
</code></pre><h3 id="配置mysql数据库"><a href="#配置mysql数据库" class="headerlink" title="配置mysql数据库"></a>配置mysql数据库</h3><p>先切换到/etc/freeradius/sql/mysql文件夹下(以便进行之后的操作)，然后登录mysql数据库：</p>
<pre><code>cd /etc/freeradius/sql/mysql
mysql -u root -p
</code></pre><p>先创建数据库radius，然后导入文件下的sql文件：</p>
<pre><code>create database radius;

source admin.sql;
source cui.sql;
source ippool.sql;
source schema.sql;
source wimas.sql;
</code></pre><p>再在mysql运行下面几句sql语句加入用户组：</p>
<pre><code>insert into radgroupreply (groupname,attribute,op,values) values (&apos;user&apos;，&apos;Auth-Type&apos;,&apos;:=&apos;,&apos;Local&apos;);
insert into radgroupreply (groupname,attribute,op,values) values (&apos;user&apos;，&apos;Service-Type&apos;,&apos;:=&apos;,&apos;Framed-User&apos;);
insert into radgroupreply (groupname,attribute,op,values) values (&apos;user&apos;，&apos;Framed-IP-Address&apos;,&apos;:=&apos;,&apos;255.255.255.254&apos;);
insert into radgroupreply (groupname,attribute,op,values) values (&apos;user&apos;，&apos;Framed-IP-Netmask&apos;,&apos;:=&apos;,&apos;255.255.255.0&apos;);
</code></pre><p>然后加入用户账号和密码（以账号test，密码123456为例）：</p>
<pre><code>insert into radcheck (username,attribute,op,value) values (&apos;test&apos;,&apos;User-Password&apos;,&apos;:=&apos;,&apos;123456&apos;)
  将账号加入用户组：

insert into usergroup (username,groupname) values (&apos;test&apos;,&apos;user&apos;);
  修改/etc/freeradius/sites-enabled/default：
</code></pre><p>找到authorize {}模块，注释掉files，去掉sql前的#号</p>
<p>找到accounting {}模块，注释掉radutmp,注释掉去掉sql前面的#号。</p>
<p>找到session {}模块，注释掉radutmp，去掉sql前面的#号。</p>
<p>找到post-auth {}模块，去掉sql前的#号，去掉sql前的#号（Post-Auth-Type REJECT内）</p>
<p>修改/etc/freeradius/sites-enabled/inner-tunnel：</p>
<p>找到authorize {}模块，注释掉files，去掉sql前的#号。</p>
<p>找到session {}模块，注释掉radutmp，去掉sql前面的#号。</p>
<p>找到post-auth {}模块，去掉sql前的#号，去掉sql前的#号（Post-Auth-Type REJECT内）。</p>
<p>到这里就基本配置完毕了。</p>
<hr>
<h3 id="本地测试"><a href="#本地测试" class="headerlink" title="本地测试"></a>本地测试</h3><p>使用调试模式启动 FreeRadius：</p>
<pre><code>freeradius -X
</code></pre><p>使用radtest模拟向服务器发送请求：</p>
<pre><code>radtest test 123456 localhost 1812 testing123
</code></pre><p>注意</p>
<p><strong>test</strong>为用户账号，<strong>123456</strong>为密码，这两个必须和我们之前在mysql数据里面写入的用户账号和密码对应，否则服务器会返回Access-reject响应，<strong>localhost</strong>和<strong>1812</strong>为FreeRadius服务器的 ip地址和端口，<br><strong>testing123</strong>是我们之前在<strong>/etc/freeradius/clients.conf</strong>里面配置的与本地客户端的共享密钥。</p>
]]></content>
    
    <summary type="html">
    
      本学期综合课程设计的内容，分享自己在ubuntu上安装FreeRadius的步骤及遇到的问题，系统为Ubuntu 14.04，数据库选用用mysql
    
    </summary>
    
      <category term="Linux" scheme="https://shadowwood.me/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://shadowwood.me/tags/Linux/"/>
    
      <category term="FreeRadius" scheme="https://shadowwood.me/tags/FreeRadius/"/>
    
  </entry>
  
  <entry>
    <title>javascript实现按钮计时</title>
    <link href="https://shadowwood.me/2015/04/18/2015-04-18-Js-button-timer/"/>
    <id>https://shadowwood.me/2015/04/18/2015-04-18-Js-button-timer/</id>
    <published>2015-04-18T10:15:30.000Z</published>
    <updated>2017-02-21T15:53:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近实验和项目忙得不可开交，终于可以闲下心来写写博客了。</p>
<p>这段时间都在做后台管理的web端，自然也离不开短信验证那一套东西，最开始对js不熟，做按钮计时花了大半时间。<br>今天就拿这个下手吧。为了方便操作html中的元素，就直接用jquery框架了。<br><a id="more"></a></p>
<p>首先先确定需要输入的东西，一个是手机号，一个是验证码。</p>
<pre><code>&lt;script src=&quot;http://cdn.bootcss.com/jquery/1.11.1/jquery.min.js&quot;&gt;&lt;/script&gt;
&lt;label&gt;手机号：&lt;/label&gt;
&lt;input id=&quot;phone&quot;&gt;
&lt;br/&gt;
&lt;label&gt;验证码：&lt;/label&gt;
&lt;input&gt;
&lt;button id=&quot;get_verify_code&quot;&gt;获取验证码&lt;/button&gt;
</code></pre><p> 首先我们得实现在用户点击意义“获取验证码”按钮后，得有一个计时机制，防止用户在短时间内多次获取验证码，而且同时也有暗示用户获取验证码这步操作已经执行。计时的功能用setInterval()函数来实现。先贴出代码：</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
    var count;
    var countdown;
    var button = $(&apos;#get_verify_code&apos;)
    function Count(){
        count--;
        button.text(&quot;请等待&quot;+count+&quot;秒&quot;);
        if(count == 0){
            clearInterval(countdown);
            button.text(&quot;获取验证码&quot;);
            button.removeAttr(&apos;disabled&apos;);
        }
    }
    button.click(function(){
        count = 30;
        $(this).text(&quot;请等待&quot;+count+&quot;秒&quot;);
        $(this).attr(&apos;disabled&apos;, true);
        countdown = setInterval(Count, 1000);
    })
&lt;/script&gt;
</code></pre><p>OK，这段代码的两个重点就是setIntercval()函数和全局变量的使用。首先我们来了解下setInterval()函数。</p>
<p>函数定义：</p>
<ul>
<li>setInterval() 方法可按照指定的周期（以毫秒计）来调用函数或计算表达式。</li>
<li>setInterval() 方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。由 setInterval() 返回的 ID 值可用作 clearInterval() 方法的参数。</li>
</ul>
<p>函数语法：</p>
<ul>
<li>setInterval(code,millisec[,”lang”])</li>
</ul>
<p>参数：</p>
<ul>
<li>code必须。要调用的函数或要执行的代码串。</li>
<li>millisec必须。周期性执行或调用 code 之间的时间间隔，以毫秒计。</li>
</ul>
<p>返回值:</p>
<ul>
<li>一个可以传递给 Window.clearInterval( ) 从而取消对 code 的周期性执行的值。</li>
</ul>
<p>我们将计时函数 Count( )  用 setInterval( ) 函数来不断执行，知道计时标志 count &lt;= 0 时，停止计时，将按钮恢复如初。在代码中我用了setInterval(Count, 1000), 其中 Count 时 Count( )函数的函数名，“1000”是指定的周期，即1000毫秒＝1秒。</p>
<p>至于为什么我要将 count 和 countdown 定义为全局变量，以下便是我的理由：</p>
<ul>
<li><p>count 作为计时标志，每次都会被函数 Count( ) 调用操作，故应将其定义为全局变量避免出现错误。</p>
</li>
<li><p>countdown 是 setInterval( ) 返回的 id 值，用来作为 clearInterval( ) 的参数停止计时，而在这里clearInterval( ) 被用在 Count( ) 之中，而 Count( ) 又是在 setInterval( ) 里被调用，为了使countdown有效，其必须定义在 setInterval( ) 之外，故将其定义为全局变量。</p>
</li>
</ul>
<p>这样一看其实还挺明显的，但是之后等我们加入下一个功能，你就会明白全局变量的重要性了。</p>
<hr>
<p>相信大家已经发现这个按钮计时有个明显的缺陷了，那就是只要你将当前的页面一刷新，按钮又可以使用了，那么做的这一切就没用了。</p>
<p>要解决这个问题有两种方案：</p>
<ul>
<li>在后台存储用户点击按钮时的时间，每次用户向后台发出页面请求的时候，判定当前的时间距离上一次点击按钮的时间相差是否有30秒，然后进行对应的操作；</li>
<li>在本地存储用户点击按钮时的时间，用法同上。</li>
</ul>
<p>这里我们为了减少向服务器请求的数据（我不会告诉你其实是我想偷懒！＝。＝），便采用第二种方案。</p>
<p>本地存储的方式有两种，一是使用 localStorage, 二是使用 sessionStorage。前者是永久存储，后者如果关闭浏览器就清空。这里我们用 localStorage。 ok，想法就这样，先贴出代码：</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
    $(document).ready(function(){
        var count;
        var countdown;
        var button = $(&apos;#get_verify_code&apos;);
        function Count(){
            count--;
            button.text(&quot;请等待&quot;+count+&quot;秒&quot;);
            if(count == 0){
                clearInterval(countdown);
                button.text(&quot;获取验证码&quot;);
                button.removeAttr(&apos;disabled&apos;);
                localStorage.removeItem(&apos;verify_time&apos;)
            }
        }
        if(localStorage[&apos;verify_time&apos;]){
            var last_time = parseInt(localStorage[&apos;verify_time&apos;]);
            var now_time = parseInt(new Date().getTime());
            if(now_time-last_time &lt; 30000){
                count = parseInt(30-(now_time - last_time)/1000);
                button.text(&quot;请等待&quot;+count+&quot;秒&quot;);
                button.attr(&apos;disabled&apos;, true);
                countdown = setInterval(Count, 1000);
            }
            else{
                localStorage.removeItem(&apos;verify_time&apos;);
            }
        }
        button.click(function(){
            count = 30;
            $(this).text(&quot;请等待&quot;+count+&quot;秒&quot;);
            $(this).attr(&apos;disabled&apos;, true);
            localStorage[&apos;verify_time&apos;] = new Date().getTime();
            countdown = setInterval(Count, 1000);
        })
    });
&lt;/script&gt;
</code></pre><p>首先用  $(ducument).ready(function( ){ })  来实现页面的初始化操作，保证需要的代码操作执行完后，才能对页面进行下一步操作。</p>
<p>这里我们将点击“获取验证码按钮”的时间用时间戳存在localStorage[‘verify_time’] 里，每次计时结束 或者 下一次刷新页面的时候已经距离上次操作30秒后，就将其删除。</p>
<p>每次刷新页面的时候，先判定本地是否记录有上次获取验证码操作的时间，若有，则计算距离上次操作时间是否超过30秒，如果低于30秒，则继续计时；否则，删除本地的记录。</p>
<p>由于 localStorage 都是存的字符串类型，所以在计算时间差和对 count 进行赋值的时候，都要将其转换为int类型。</p>
<p>在这里，我们就能发现重视全局变量带来的好处了，count 和 countdown 虽然都会被函数以及函数的内层调用，但是这些函数都不是在同时对这两个变量进行操作，所以理论上不会引起冲突，故而将 count 和 countdown 定义为全局变量，不仅使得逻辑清楚，还使得代码简洁，减少了很多不必要的操作。</p>
<p>在这之前，我犯过许多错，其中就包括对全局变量的使用不当，也是由于python用惯了，没重视这方面问题，老是喜欢使用局部变量，使得代码逻辑混乱，半天找不出问题。</p>
<p>最后爽性全删掉，重新整理思路，删繁就简，最后才发现，其实完全可以用全局变量，不仅清晰易懂，还减少了很多不必要的操作。</p>
]]></content>
    
    <summary type="html">
    
      在web端实现简单的按钮计时，防止用户短时间内重复的操作
    
    </summary>
    
      <category term="Javascript" scheme="https://shadowwood.me/categories/Javascript/"/>
    
    
      <category term="javascript" scheme="https://shadowwood.me/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu上搭建PPPoE认证服务器</title>
    <link href="https://shadowwood.me/2015/04/18/2015-04-18-build-PPPoE-On-Ubuntu/"/>
    <id>https://shadowwood.me/2015/04/18/2015-04-18-build-PPPoE-On-Ubuntu/</id>
    <published>2015-04-18T05:13:37.000Z</published>
    <updated>2017-02-21T15:53:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p> 对于PPPoE很多人应该不陌生，拨号上网都碰过这玩意儿，但是在后台到底是怎么实现这个认证的，了解的人应该不多。<br>正好这学期综合课程设计老师要求搞这玩意儿，那就搞搞咯，时间上的话大概一天就搞定了，但是之后去理解这些配置做了什么东西还是花了很久时间。<br><a id="more"></a></p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ul>
<li>系统：ubuntu14.04</li>
<li>PPPoE软件：ppp</li>
<li>虚拟机网络模式：PPPoE服务器(双网卡：host-only模式 + 桥接模式), radius服务器(host-only模式)</li>
</ul>
<h3 id="搭建PPPoE服务器"><a href="#搭建PPPoE服务器" class="headerlink" title="搭建PPPoE服务器"></a>搭建PPPoE服务器</h3><p>首先直接通过apt-get安装ppp软件：</p>
<pre><code>sudo apt-get install ppp
</code></pre><p>然后修改ppp的配置文件options，该文件在/etc/ppp文件夹下</p>
<pre><code>cd /etc/ppp
sudo gedit options
</code></pre><p>在这里我们需要修改几个地方：</p>
<ul>
<li>设置ms-dns： 这个参数是设置给客户端的dns服务器地址，和 PPPoE 服务器的dns服务器地址对应，可用查看自己服务器网络的dns地址并复制上去；</li>
<li>注释掉+pap，取消掉-pap的注释，表示 PPPoE 服务器不使用pap认证方式；</li>
<li>取消掉+chap的注释，表示PPPoE服务器使用chap认证方式；</li>
</ul>
<p>然后我们设置 chap-secrets 文件，直接在最后一行按 用户名服务器名密码ip地址 的格式插入，例如：</p>
<pre><code>test * 123456 *
</code></pre><p>表示用户名为test ，服务器为任意，密码为123456，ip地址任意</p>
<p>接下来配置 pppoe-server-options 文件，如果/etc/ppp目录下没有这个文件就新建一个，在文件中其他的删除或者注释掉，写入以下内容：</p>
<pre><code>auth
require-chap
logfile /var/log/pppd.log
</code></pre><p>到这里，PPPoE的服务器的基本配置算完成了，但是为了让客户端连上外网，我们还需要进一步的配置。</p>
<p>开启ip转发功能，在超级用户的身份下(即先使用 sudo su 切换到超级用户)，再执行以下命令：</p>
<pre><code>cat 1 &gt; /proc/sys/net/ipv4/ip_forward
</code></pre><p>这个命令只能暂时将ip转发功能打开，重启之后便会自动关闭，若需要一直打开ip转发功能，需要编辑 /etc/sysct1.conf , 将 net.ipv4.ip_forward=1 的注释取消掉，然后再执行 sudo sysct1 -p便可永久开启ip转发功能。</p>
<p>配置iptables，使用超级用户执行以下命令：</p>
<pre><code>iptables -A POSTROUTING -t nat -s 11.11.11.0/24 -j MASQUERADE
</code></pre><p>11.11.11.0/24 是我们之后给客户端分配的ip地址池，可以根据自己的喜好替换，只需要与之后开启pppoe-server的 地址相对应即可。</p>
<p>关于iptables，是一个内核防火墙模块，可以实现数据包的过滤和转发，具体请参见iptables的man手册。</p>
<p>最后开启 PPPoE 服务器：</p>
<pre><code>sudo pppoe-server -I eth1 -L 11.11.11.1 -R 11.11.11.10 -N 20
</code></pre><p>注意</p>
<ul>
<li>-I 后的参数用于指定监听哪个网络端口。可以使用ifconfig命令查看当前工作的端口名称。笔者的虚拟机的host-only的网卡为eth1，所以使用这个网卡。</li>
<li>-L 后的参数用于指定在一个PPP连接中PPPoE服务器的IP地址，之前我们在配置网关的时候确定的ip地址池为 11.11.11.0/24，所以这里我们要与之对应，变使用11.11.11.1作为PPPoE服务器地址。</li>
<li>-R 后的参数用于指定当有客户连接到服务器上时，从哪个IP地址开始分配给客户。</li>
<li>-N 后的参数用于指定至多可以有多少个客户同时连接到PPPoE服务器上。</li>
</ul>
<p>至此，PPPoE服务器搭建完毕，可以直接在另一个虚拟机的windows客户端上进行拨号连接，账号名为test，密码为123456，如果PPPoE服务器的桥接网卡能用来上网的话，那么windows客户端也能上网。</p>
<p>可能的问题</p>
<ul>
<li>如果windows客户端连接的时候无法检测到PPPoE服务器的存在，即无法通过wan口发现PPPoE服务器，检查一下自己的PPPoE服务器是否启动成功。</li>
<li>如果windows客户端连接上了PPPoE服务器但是无法连上外网，先检查自己的PPPoE服务器是否能连上外网，若没有问题，再检查自己PPPoE的ip转发配置、options中的ms-dns是否配置正确 或者 iptables中的配置是否和pppoe-server分配给客户端的ip地址池一致</li>
</ul>
<hr>
<p>参考博客</p>
<ul>
<li><a href="http://blog.chinaunix.net/uid-9525959-id-4008338.html" target="_blank" rel="external">http://blog.chinaunix.net/uid-9525959-id-4008338.htm</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt; 对于PPPoE很多人应该不陌生，拨号上网都碰过这玩意儿，但是在后台到底是怎么实现这个认证的，了解的人应该不多。&lt;br&gt;正好这学期综合课程设计老师要求搞这玩意儿，那就搞搞咯，时间上的话大概一天就搞定了，但是之后去理解这些配置做了什么东西还是花了很久时间。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://shadowwood.me/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://shadowwood.me/tags/Linux/"/>
    
      <category term="PPPoE" scheme="https://shadowwood.me/tags/PPPoE/"/>
    
  </entry>
  
  <entry>
    <title>python网络爬虫入门</title>
    <link href="https://shadowwood.me/2015/02/10/2015-02-10-python-spider-simple/"/>
    <id>https://shadowwood.me/2015/02/10/2015-02-10-python-spider-simple/</id>
    <published>2015-02-10T00:13:30.000Z</published>
    <updated>2017-02-21T15:53:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>对于刚刚接触python的人并且没有什么编程基础的人来说，从网络爬虫开始入门是个不错的选择。<br>学习一门编程语言要从实践中去学习，必须要自己动手操作，光是看一系列的编程书籍，不动动手做几个实际的程序运行运行，是完全不可能掌握一门语言的。<br>就好比武侠小说里学习一门武功一样，光是看别人操练，自己不比划比划，难道就能练就一身好功夫么？这样的话以后出身江湖不被别人砍死都是万幸了。</p>
<p>网络爬虫是我学习python(甚至可以说学习编程)的第一个程序(“Hello World”什么的就算了把)。所以在此极力推荐初学python的人选择从网络爬虫作为入门学习的选择。<br><a id="more"></a></p>
<h3 id="网络爬虫简介"><a href="#网络爬虫简介" class="headerlink" title="网络爬虫简介"></a>网络爬虫简介</h3><p>简单来说网络爬虫就是按照一定的算法和规则，自动的抓取网络信息的程序或者脚本。比较常用的也是这里要给大家介绍的基于HTTP协议的抓取网页并从中提取特定信息的脚本。</p>
<p>我们平常用浏览器打开一个网页，都是想网页的服务器端发送一个请求，然后服务器端做一系列的判断和处理，返回给我们一个HTML文件，然后我们的浏览器再将HTML文件解析成可视化的视图供我们浏览和操作。而这里要给大家介绍的爬虫就是将获取到HTML文件中的字符进行匹配和分析，提取我们需要的数据。</p>
<h3 id="获取网页"><a href="#获取网页" class="headerlink" title="获取网页"></a>获取网页</h3><p>对于python的介绍和安装，百度或谷歌一搜一大片，这里我也不再做介绍，我们直接切入正题。</p>
<p>python作为一门脚本语言，自身集合了很多WEB操作的库，再结合其简洁的语法，往往只需要简单几行代码，就能完成一些复杂的请求和分析。</p>
<p>现在我们以抓取天涯论坛的帖子为例。</p>
<ul>
<li><a href="http://bbs.tianya.cn/post-culture-308737-1.shtml" target="_blank" rel="external">http://bbs.tianya.cn/post-culture-308737-1.shtml</a></li>
</ul>
<p>这是一篇天涯论坛上的小说，现在我们准备写一个简单的网络爬虫，把这个网页的帖子抓取下来。</p>
<pre><code>import urllib

url = &quot;http://bbs.tianya.cn/post-culture-308737-1.shtml&quot;
re_f = urllib.urlopen(url)
page = re_f.read()
print page
</code></pre><p>urllib为python系统库专门用来处理WEB请求的一个包，用这个包可以实现向服务器端发送HTTP请求。</p>
<p>代码运行的结果是一整串的HTML代码，也就是我们做访问网页的源代码,就这样我们像浏览器一样获取网页的请求就完成了。</p>
<h3 id="匹配字符串获取数据"><a href="#匹配字符串获取数据" class="headerlink" title="匹配字符串获取数据"></a>匹配字符串获取数据</h3><p>接下来我们要对获取到的网页信息做处理，只抓取我们需要的数据。这里以抓取文章标题为例。</p>
<pre><code>import urllib
import re

url = &quot;http://bbs.tianya.cn/post-culture-308737-1.shtml&quot;
re_f = urllib.urlopen(url)
page = re_f.read()
content = re.findall(&quot;&lt;title&gt;(.*?)_.*?&lt;/title&gt;&quot;, page)
print content[0]
</code></pre><p>这里使用了正则表达式，关于正则表达式我之后会写一篇文章详细介绍。</p>
<p>re为python系统库用来处理正则表达式匹配的一个包。通过对网页源码的分析，我们不难发现，我们所需要的文章标题在标签<title>之中，但是这个标签的具体内容是这样的：</title></p>
<pre><code>&lt;title&gt;男人密码:《妻子，请原谅我》(已出版)_舞文弄墨_天涯论坛&lt;/title&gt;
</code></pre><p>我们所需要的内容只有“男人密码:《妻子，请原谅我》(已出版)”，title标签和“<em>舞文弄墨</em>天涯论坛”我们都不需要，所以我们将 “<title>“与”<em>舞文弄墨</em>天涯论坛”之间的内容用”()”提取出来即可，其中.*?表示匹配任意字符串。</title></p>
<p>re.findall()返回的是一个列表，我们只需要将第一个元素提取出来即可。</p>
<p>到这里，仅仅只用几行代码，一个简单的小爬虫就完成了。</p>
<hr>
<p>上一部分主要讲解了如何使用python发送HTTP  GET 请求并简单处理获取到的数据，其中用到了 urllib 和 re 库。http协议常用的请求中除了 GET 方法，还有 POST 方法。POST 方法与 GET 方法的区别网上已经有很多讲解了，这里笔者也不再赘述，简单的来说 GET 方法用于信息获取，POST 方法可能会对服务器上的资源进行修改。本篇文章以发送手机短信为例，讲解如何发送http POST请求。</p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>这里笔者选用的短信服务商为云片网，关于云片网的api文档请移步这里：</p>
<ul>
<li><a href="http://www.yunpian.com/api/sms.html" target="_blank" rel="external">http://www.yunpian.com/api/sms.html</a></li>
</ul>
<p>在api文档里已经有调用短信接口的python代码示例，不过示例代码中使用的是urllib库。因此笔者在这里使用urllib2进行编写，这个库也是python的标准库之一，用来处理http请求非常方便。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code># -*- coding: utf-8 -*-
import urllib2
import urllib


url = &quot;http://yunpian.com/v1/sms/send.json&quot;
data = urllib.urlencode({&apos;apikey&apos;: &quot;***********************&quot;,
                         &apos;mobile&apos;: &apos;****************&apos;,
                         &apos;text&apos;: &quot;【云片网】您的验证码是1234&quot;})
response = urllib2.urlopen(url, data)
print response.read()
</code></pre><h3 id="代码讲解"><a href="#代码讲解" class="headerlink" title="代码讲解"></a>代码讲解</h3><p>apikey 对应云片网账号的 apikey，mobile 为需要发送短信的手机号码。</p>
<p>urllib.urlencode() 是将字典或包含两个元素的列表或元组转换为url参数，读者可以print一下本例的 data，结果输出为:</p>
<pre><code>“mobile=15682513909&amp;text=%E3%80%90%E4%BA%91%E7%89%87%E7%BD%91%E3%80%91%E6%82%A8%E7%9A%84%E9%AA%8C%E8%AF%81%E7%A0%81%E6%98%AF1234&amp;apikey=d25fbaa9ed5025eef7b777ca73c56af3”(text输出格式为unicode)。
</code></pre><p>urllib2.urlopen()创建一个表示远程url的类文件对象，然后像本地文件一样操作这个类文件对象来获取远程数据。当只传入url参数时，该函数将使用HTTP GET向url发送请求,当同时传入url和data参数时，该函数则使用HTTP POST方法向url发送请求。返回为一个类文件对象，该对象提供如下方法：</p>
<ul>
<li><p>read(), readline(), readlines(), fileno(), close()：这些方法的使用方式与文件对象完全一样，读者可以自行了解python对于文件对象的处理；</p>
</li>
<li><p>info()：返回一个httplib.HTTPMessage对象，表示远程服务器返回的头信息；</p>
</li>
<li><p>getcode()：返回HTTP状态码；</p>
</li>
<li><p>geturl()：返回请求的url；</p>
</li>
</ul>
<h3 id="代码进阶"><a href="#代码进阶" class="headerlink" title="代码进阶"></a>代码进阶</h3><p>对于以上的代码urllib2也能做到，而且在使用上几乎没有区别，那么这里我们对代码进行一些修改：</p>
<pre><code># -*- coding: utf-8 -*-
import urllib2
import urllib


url = &quot;http://yunpian.com/v1/sms/send.json&quot;
data = urllib.urlencode({&apos;apikey&apos;: &quot;***********************&quot;,
                     &apos;mobile&apos;: &apos;****************&apos;,
                     &apos;text&apos;: &quot;【云片网】您的验证码是1234&quot;})
req = urllib2.Request(url, data)
response = urllib2.urlopen(req)
print response.read()
</code></pre><p>其中我们引入了Request对象，并且直接在urllib2.urlopen()中传入Request对象，代码依旧能执行。在python官方的urllib2文档中，有这么一句话“Open the URL url, which can be either a string or a Request object.” 对于传入的url参数，可以直接是字符串，也可以是Request对象，而在urllib之中没有这种用法。</p>
<p>对于Request对象，我们可以通过它来修改 HTTP 请求的 header 和 proxy，这个我们在之后的文章会讲解，这里先提出这个用法，以免在以后的使用和介绍中显得突兀。</p>
<p>以上代码的最终结果是一个json字符串，使用type()方法返回值为str。可以使用python的json库，使用json.loads()将json字符串转换为数据原本的格式，本例的最终原本的数据为字典。</p>
<hr>
<p>有了以上的基础，我们可以尝试实现一个简单的模拟登录</p>
<h3 id="什么是模拟登录"><a href="#什么是模拟登录" class="headerlink" title="什么是模拟登录"></a>什么是模拟登录</h3><p>在很多网站上都会有一套用户系统，那么肯定就免除不了会有登录操作，并且许多信息和操作只有在登录之后才能实现。目前网站上判断用户是否登录有大概两种方式：</p>
<ul>
<li><p>使用cookie来对应记录用户的登录状态以及有效时间</p>
</li>
<li><p>自定义一个token，发送给已经登录的用户，里面存储了用户的一些信息已经登录状态有效时间</p>
</li>
</ul>
<p>这两种方式的思想都大同小异吧，目前我们主要对使用cookie进行登录判定的网站举例讲解。</p>
<h3 id="需要准备的工具"><a href="#需要准备的工具" class="headerlink" title="需要准备的工具"></a>需要准备的工具</h3><p>用户抓包的工具：chrome、firefox的firebug插件。至于抓包工具如何使用，大家可以自行搜索。</p>
<h3 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h3><p>首先我们需要通过抓包工具获取如下三个信息：</p>
<ul>
<li><p>post请求的网址</p>
</li>
<li><p>post请求的参数</p>
</li>
<li><p>post请求的返回值</p>
</li>
</ul>
<p>然后我们就针对以上获取到的数据进行下一步操作</p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>以电子科技大学的信息门户登录为例，需要用到的包:urllib，urllib2，cookielib</p>
<pre><code># -*- coding: utf-8 -*-
import urllib
import cookielib
import urllib2


loginUrl = &quot;https://uis.uestc.edu.cn/amsever/UI/Login&quot;
postUrl = &quot;https://uis.uestc.edu.cn/amserver/UI/Login&quot;
# 初始化一个CookieJar来处理cookie信息
cookieJar = cookielib.CookieJar()

# 初始化一个opener
cJHandler = urllib2.HTTPCookieProcessor(cookieJar)
opener = urllib2.build_opener(cJHandler, urllib2.HTTPHandler)
urllib2.install_opener(opener)

# 用get请求访问网站，获取必要的cookie值

res1 = opener.open(loginUrl)

# 用post请求向url提交表单

postData = {&quot;IDToken0&quot;: &quot;&quot;,
            # 登录用户名
            &quot;IDToken1&quot;: &quot;这里填写你的登录用户名&quot;,
            # 登录密码
            &quot;IDToken2&quot;: &quot;这里填写你的登录密码&quot;,
            &quot;IDButton&quot;: &quot;Submit&quot;,
            &quot;goto&quot;: &quot;aHR0cDovL3BvcnRhbC51ZXN0Yy5lZHUuY24vbG9naW4ucG9ydGFs&quot;,
            &quot;encoded&quot;: &quot;true&quot;,
            &quot;gx_charset&quot;: &quot;UTF-8&quot;}
postData = urllib.urlencode(postData).encode(encoding=&apos;UTF8&apos;)
req = urllib2.Request(postUrl, postData)
response = opener.open(req)
print response.read()
</code></pre><p>不出意外的话，打印的结果就是登录成功后返回的网页。</p>
<h3 id="代码讲解-1"><a href="#代码讲解-1" class="headerlink" title="代码讲解"></a>代码讲解</h3><p>相对于之前的爬虫代码，这里多了一个cookie的管理，所以我们使用了cookielib包来生成一个CookieJar对象来自动处理返回的cookie值。</p>
<p>之后我们需要将获取到的cookie值写入我们的每一次http请求中，于是我们使用了urllib2.build_opener()来生成一个OpenerDirector对象，而在一个OpenerDirector里面有很多的处理类，我们称之为handler。这些handler可以帮我们完善我们的http请求，比如本例中的向http请求中加入获取到的cookie。在调用了urllib2.builde_opener()之后，我们需要再调用urllib2.install_opener()来将生成的OpenerDirector实例化，这样在之后我们就可以使用OpenerDirector的open方法来代替urllib2.urlopen()方法了(当然你之后继续使用urllib2.urlopen()也不会有问题)</p>
<p>在模拟登录操作成功之后，我们就可以通过get或者post请求直接访问获取我们登录后才能看到的信息了，如个人学籍信息等，不过一定要使用urllib2.urlopen()或者OpenerDirector.open()方法来发送请求，因为我们之后的操作必须使用到我们之前登录成功获取到的cookie值，所以我们必须用我们生成的OpenerDirector对象的open方法来发送请求（其实urllib2.urlopen()也是默认调用当前OpenerDirector对象的open()方法）。</p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>对于模拟登录的方法，实现方式不止以上的一种，不过基本思想都是一致的。归根结底就是用户先向服务器发送需要认证的信息，然后服务器返回给你一个身份标识，之后用户每次向服务器发送请求的时候，都将这个身份标识一起发给服务器，向服务器证明你是一个登录的合法用户，然后服务器返回给用户应该看到的和想看到的数据。</p>
]]></content>
    
    <summary type="html">
    
      本文将介绍python基本的网络请求方式，以及网页抓包分析，适合于刚开始接触python的人学习
    
    </summary>
    
      <category term="Python" scheme="https://shadowwood.me/categories/Python/"/>
    
    
      <category term="python" scheme="https://shadowwood.me/tags/python/"/>
    
      <category term="网络爬虫" scheme="https://shadowwood.me/tags/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
</feed>
